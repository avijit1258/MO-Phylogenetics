//  PhylogeneticMutation.cpp
//
//  Author:
//       Cristian G. Zambrano Vega <cristian_uteq@hotmail.com>
//
//  Copyright (c) 2011 Antonio J. Nebro, Juan J. Durillo
//
//  This program is free software: you can redistribute it and/or modify
//  it under the terms of the GNU Lesser General Public License as published by
//  the Free Software Foundation, either version 3 of the License, or
//  (at your option) any later version.
//
//  This program is distributed in the hope that it will be useful,
//  but WITHOUT ANY WARRANTY; without even the implied warranty of
//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//  GNU Lesser General Public License for more details.
//
//  You should have received a copy of the GNU Lesser General Public License
//  along with this program.  If not, see <http://www.gnu.org/licenses/>.

#include <PhylogeneticMutation.h>


/**
 * Constructor
 * Creates a new instance of the SPR mutation operator
 */
PhylogeneticMutation::PhylogeneticMutation(map<string, void *> parameters)
: Mutation(parameters) {

   mutationProbability_=0;  Metodo="NNI";
    
   string NumExp = *(string *) parameters["NumExp"];
   if (parameters["metodo"] != NULL)              Metodo = *(string *) parameters["metodo"];
   if (parameters["probability"] != NULL)         mutationProbability_ = *(double *) parameters["probability"];
   if (parameters["NumIteracionesPPN"] != NULL)   NumIteraciones  = *(int *) parameters["NumIteracionesPPN"];
   
   
   if (parameters["optramas"] != NULL)            OptRamas  = *(bool *) parameters["optramas"];
   if (parameters["MetodoOptRamas"] != NULL)      MetodoOptRamas  = *(string *) parameters["MetodoOptRamas"];
   if (parameters["NumIterOptRamas"] != NULL)     NumIterOptRamas  = *(int *) parameters["NumIterOptRamas"];
   if (parameters["TolerenciaOptRamas"] != NULL)  TolerenciaOptRamas  = *(double *) parameters["TolerenciaOptRamas"];

   if (parameters["OptimizacionSubstModel"] != NULL)  OptimizacionSubstModel  = *(bool *) parameters["OptimizacionSubstModel"];
   if (parameters["MetodoOptimizacionSubstModel"] != NULL) MetodoOptimizacionSubstModel  = *(string *) parameters["MetodoOptimizacionSubstModel"];
   if (parameters["NumIterOptSubstModel"] != NULL)     NumIterOptSubstModel  = *(int *) parameters["NumIterOptSubstModel"];
   if (parameters["TolerenciaOptSubstModel"] != NULL)  TolerenciaOptSubstModel  = *(double *) parameters["TolerenciaOptSubstModel"];


   if (parameters["OptimizacionRateDist"] != NULL)  OptimizacionRateDist  = *(bool *) parameters["OptimizacionRateDist"];
   if (parameters["MetodoOptRateDistB"] != NULL)    MetodoOptRateDistB  = *(string *) parameters["MetodoOptRateDistB"];
   
   
   
   random_gsl = gsl_rng_alloc(gsl_rng_default);
   randomgsl_alpha = 500;
   
   
   comparator = new DominanceComparator();
   
   //std::strcpy(NumExp,"ComportamientoML");
   ComportamientoML.open("ComportamientoML"); ComportamientoTime.open("ComportamientoTime");
  
   
} // PhylogeneticMutation



void PhylogeneticMutation::printParameters(){
   
   cout << "************** Mutation Operator Parameters ************ " << endl;
   cout << "mutationProbability: " << mutationProbability_ << endl;
  
   cout << "Método de Mutación: " <<  Metodo << endl;
   cout << "Número de Iteraciones  " << NumIteraciones << endl;
   
   
   cout << "Optimización Ramas:  " <<  OptRamas << endl;
   if(OptRamas){
       cout << "Método Optimización Ramas: " <<  MetodoOptRamas << endl;
       cout << "Num Iteraciónes Opt. Ramas : " <<  NumIterOptRamas << endl;
       cout << "Tolerencia Opt. Ramas : " <<  TolerenciaOptRamas << endl;
   }
   
   cout << "Optimización Substitution Model:  " <<  OptimizacionSubstModel << endl;
   if(OptimizacionSubstModel){
       cout << "Método Optimización Substitution Model: " <<  MetodoOptimizacionSubstModel << endl;
       cout << "Num Iteraciónes Opt. Substitution Model: " <<  NumIterOptSubstModel << endl;
       cout << "Tolerencia Opt. Substitution Model : " <<  TolerenciaOptSubstModel << endl;
   }
   
    cout << "Optimización Rate Distribution:  " <<  OptimizacionRateDist << endl;
   if(OptimizacionRateDist){
       cout << "Método Optimización Rate Distribution: " <<  MetodoOptRateDistB << endl;
   }
   
   cout << endl;
}

/**
 * Destructor
 */
PhylogeneticMutation::~PhylogeneticMutation() { 

        ComportamientoML.close();	ComportamientoTime.close();
        
} // ~PhylogeneticMutation


/**
 * Perform the mutation operation
 * @param probability Mutation probability
 * @param solution The solution to mutate
 */
void * PhylogeneticMutation::doMutation(double mutationProbability_, Solution *solution) {
    
    if ( PseudoRandom::randDouble() <= mutationProbability_) {
        
                if(Metodo=="ppn") PPNOptimiz(solution); 
                /*else if(Metodo=="nni") NNIandBranchMutate(solution); 
                else if(Metodo=="spr") SPRPhyloMOEA(solution);
                else if(Metodo=="trb") TBR(solution);
                else   NNIMoves(solution); */
    }

    //if(OptRamas || OptModeloyTasaDist)  OptimizarRamasyParamModeloSust(solution);


} // doMutation

void PhylogeneticMutation::TBR(Solution * solution){
    vector<int> nodosIDs;
    Variable **variables = solution->getDecisionVariables();
    PhyloTree * Pt = (PhyloTree*) variables[0];
    TreeTemplate<Node> * tree = Pt->getTree();

    Node * nodo;
    Node * nodoi;
    Node * nodoj;
    Node * nodoPadre;
    Node * nodoSubTree;

    nodosIDs = tree->getNodesId();
    do{
              do{
                      nodo = tree->getNode(RandomTools::pickOne(nodosIDs,true));
              }while(nodo->isLeaf() || nodo->getNumberOfSons() < 2 || !nodo->hasFather());

              if (RandomTools::flipCoin()) {
                      nodoi= nodo->getSon(0); nodoj= nodo->getSon(1);
              }else{
                      nodoi= nodo->getSon(1); nodoj= nodo->getSon(0);
              }

     }while(nodoi->isLeaf());

     TreeTemplate<Node> * subtree = new TreeTemplate<Node>(nodoi);
     subtree->resetNodesId();
     nodosIDs = subtree->getNodesId();
     do{
            nodoSubTree = subtree->getNode(RandomTools::pickOne(nodosIDs,true));
     }while(nodoSubTree->isLeaf());

     subtree->rootAt(nodoSubTree->getId());

     nodoPadre = nodo->getFather();
     nodoPadre->setSon(nodoPadre->getSonPosition(nodo),nodoj);
     tree->resetNodesId();
     nodosIDs = tree->getNodesId();
     do{
              nodo = tree->getNode(RandomTools::pickOne(nodosIDs,true));
     }while(nodo->isLeaf());


     int posSon;
     if (RandomTools::flipCoin()) posSon=0; else posSon=1;

     Node * nuevonodo = new Node();
     nuevonodo->addSon(nodo->getSon(posSon));
     nuevonodo->addSon(subtree->getRootNode());

     nodo->setSon(posSon,nuevonodo);
     tree->resetNodesId();

}


bool PhylogeneticMutation::isMov(vector< pair<int , int > > vIDS, int IDN1, int IDN2){
    pair<int , int > eIDS;
     
    for (int i=0;i<vIDS.size();i++){
         eIDS = vIDS[i];
         if(eIDS.first == IDN1 and eIDS.second == IDN2)            return true;
    }
    return false;
}
/*
 Recorre las NIteraciones con SPR, y se queda con el que MENOR Parsimonia da, luego hace esl SPR Movimiento
 * y de parte del Max Likelihood optimiza las tres ramas SPR afectadas
 * Se supone que el mejor SPR es casi el Mejor LikeLikhood, pero igual ayudo al LikeliHood
 */

void PhylogeneticMutation::PPNOptimiz(Solution * solution){
    //cout <<"============================================================" << endl;

    //Optimized Tree 
    PhyloTree * Pt = (PhyloTree*) solution->getDecisionVariables()[0];
    Phylogeny * problem_ = (Phylogeny *) solution->getProblem();
    TreeTemplate<Node> * tree = Pt->getTree();

    vector< pair<int , int > > MovSPRPar; //Almacena todos los MovsSPR ya hechos entres ID1 y ID2
    pair<int , int> IDs;        //Mejor Mov SPR ID1 ID2 
    
    pair<int , int> BestMovSPRPar;        //Mejor Mov SPR ID1 ID2 
    
    
    //DRTreeParsimony usado para denotar los posibles buenos moviemitos basads en Parsimonia
    DRTreeParsimonyScore * Par =	new DRTreeParsimonyScore(*tree, *problem_->getSites() ,false,true);
    TreeTemplate<Node> * treeP = Par->getTreeP_();
    vector<Node*> nodes = treeP->getNodes();
    int NextNodeIDPar = treeP->getNextId();

  
    int ParsimonyScore;
    int MenorParsimonia = Par->getScore();
    //cout << "Parsimonia I " << MenorParsimonia << " ";
    
     
    Node * Root;
    Node* Nodo1;
    Node* Nodo2;

  int MaxNivel, dmax,d,up,down,u, Iteracion;
  bool b;
  
  pair< pair<double *, int *>, Node *> pPar;
  pair<double *, int *> pnPar;
  
  Root=treeP->getRootNode();
  MaxNivel=0;
  for(int k=0;k<Root->getNumberOfSons();k++){      MaxNivel+= getNivel(Root->getSon(k));   }

  dmax =MaxNivel; 
  //cout << "Dmax = " << dmax << endl;
   
  BestMovSPRPar.first=-1;  BestMovSPRPar.second=-1;
   
  for(Iteracion=0; Iteracion<NumIteraciones;Iteracion++){
      
        if (Iteracion%(NumIteraciones/MaxNivel+1)==0) dmax--;
      
        if(dmax < 3) dmax=3;
        else if(dmax > MaxNivel) dmax=MaxNivel;

        do{
              b=true;
              do {
                  Nodo1 =  nodes[rand()%nodes.size()];
                  if(Nodo1->hasFather()){
                      if(Nodo1->getFather()->hasFather()) b=false;
                  }
              }while(b);

              d=rand()%dmax+1; //Distancia entre 1 y DMax
              u=up=rand()%d+2; //Subir desde 2 a D

              Nodo2=Nodo1;
              Node* prev;
              while(Nodo2->hasFather() && (u>0)) {
                 prev=Nodo2;
                 Nodo2=Nodo2->getFather();
                 u--;
              }

              down=d+2-up-u;

            while(Nodo2->getNumberOfSons()>1 && (down>0)) {
                  Nodo2 = Nodo2->getSon(rand()% Nodo2->getNumberOfSons());
                  if(Nodo1==Nodo2) {
                      Nodo2=Nodo2->getFather();
                  }else  down --;
            }
         }while(!SPRvalide (Nodo1,Nodo2));
         
         
         
         if(!isMov(MovSPRPar,Nodo1->getId() , Nodo2->getId())){
      
             IDs.first=Nodo1->getId();         IDs.second=Nodo2->getId();
             MovSPRPar.push_back(IDs);
             
            //cout << "SPR 1" << endl;
            pPar=SPR(Nodo1, Nodo2, NextNodeIDPar); //Sobrr TreeParsimonia
            pnPar = pPar.first;
            //cout << "SPR 2" << endl;

            Par->topologyChangeTested(*new TopologyChangeEvent());
            //cout << "topologyChangeTested 2" << endl;

            ParsimonyScore = Par->getScore();
            if( ParsimonyScore < MenorParsimonia){
                
                MenorParsimonia = ParsimonyScore;
                
                BestMovSPRPar.first= IDs.first;
                BestMovSPRPar.second= IDs.second;
                
            }
            
          //cout << "Mejor Parsimonia SPR " << ParsimonyScore << endl;
           double *b = pnPar.first;
           if(b[0]==1){
              //cout << "SPR R 1" << endl;
              SPR(Nodo1,pPar.second,b);
              //cout << "SPR R 2" << endl;
           }else{
               //cout << "SPrrever 1" << endl;
               SPRreverse(Nodo1,pPar.second,b,NextNodeIDPar);
              //cout << "SPrrever 2" << endl;
            }
          

           delete[] pnPar.first;       delete[] pnPar.second;
          //if(Iteracion%100==0)      cout << "Iteracion " << Iteracion << endl; //<< " DMax " << dmax << " de " << MaxNivel << endl;
        
       }
  }
  
  delete Par;
   
  if(BestMovSPRPar.first!=-1 and BestMovSPRPar.second!=-1){
      
        double NewLik = 0;
        int NextNodeIDMutada = tree->getNextId();
            
        pPar = SPR(tree->getNode(BestMovSPRPar.first),tree->getNode(BestMovSPRPar.second), NextNodeIDMutada);
        pnPar = pPar.first;

       // NewLik =  OptimizarRamas(tree, Pt, problem_,  NumIterOptRamas, TolerenciaOptRamas);
        
        int  *IDS = pnPar.second;
        vector<string> Ramas;
        vector <Node *> nodos = tree->getNodes();
        //Los BarnchNamesPropertys seran los mismos sobre el tree del RHomerLik a Optimizar
        for(int k=0;k<3;k++)  Ramas.push_back(getBrachNameProperty(IDS[k],nodos));

        double * BranchOptimizadas = OptimizarRamasAfterSRP(tree, Pt, Ramas, problem_, NumIterOptRamas, TolerenciaOptRamas);
        for(int k=1;k<4;k++) {
             //if(BranchOptimizadas[k]!=0){
                      tree->getNode(IDS[k-1])->setDistanceToFather(BranchOptimizadas[k]);
             //}
        }
        NewLik =  BranchOptimizadas [0];   
        
        delete[] BranchOptimizadas;
        
        
       //comprobar que pasandole las longi otimizadas queda mismo scroe del optimizas
       /*problem_->evaluate(solution);
       if( abs(solution->getObjective(0) - MenorParsimonia) > 2 or abs(solution->getObjective(1) -NewLik)>0.001  ){
                cout << "Error No da el mismo Parmisonia que TreeMutada que treeParsimonia " << solution->getObjective(0) << " " << MenorParsimonia  << "  Lik= " << solution->getObjective(1) << " " << NewLik << endl;
                cout << "Diferencia MP " << abs(solution->getObjective(0) - MenorParsimonia) << " ML " << abs(solution->getObjective(1) - NewLik) << endl;
                exit(-1);
        }*/

         problem_->evaluate(solution,(float)MenorParsimonia,NewLik); //Asigna los Scores y Graba en Files
        //solution->setObjective(0,MenorParsimonia);
        //solution->setObjective(1,NewLik);
        
  }else{
      cout << "Ya No hay Ningun SPR BUENO " << endl;
  }
  
     /*nodes = tree->getNodes();
     double gamma; double distance;
     for(unsigned int i = 0; i < nodes.size(); i++){
       if (PseudoRandom::randDouble() <= 0.5) {
            if (nodes[i]->hasDistanceToFather()){
                     distance = nodes[i]->getDistanceToFather();
                     gamma =  gsl_ran_gamma (random_gsl, randomgsl_alpha, (1.0/randomgsl_alpha) );
                     if (distance * gamma != 0)	 nodes[i]->setDistanceToFather(distance * gamma);
             }
         }
     }*/
  
 //cout << "Parsimonia F " <<  solution->getObjective(0) << "  Likelihood F " << solution->getObjective(1)  << endl;
 //cout <<"============================================================" << endl;
}
    

pair< pair<Node*, Node*>  , pair<int, int> > PhylogeneticMutation::NNI(Node * NodoSel){
    
    pair<Node*, Node*> pnodos;
    pair<int, int> pos;
    
    pair< pair<Node*, Node*> ,pair<int, int> > p;
    
    Node * Nodo1;
    Node * Nodo2;
    int Pos1, Pos2;

    Pos1 = PseudoRandom::randInt(0, NodoSel->getSon(0)->getNumberOfSons()-1);
    Pos2 = PseudoRandom::randInt(0, NodoSel->getSon(1)->getNumberOfSons()-1);

    Nodo1=  NodoSel->getSon(0)->getSon(Pos1);
    Nodo2=  NodoSel->getSon(1)->getSon(Pos2);

    NodoSel->getSon(0)->setSon(Pos1,Nodo2);
    NodoSel->getSon(1)->setSon(Pos2,Nodo1);

    pnodos.first=Nodo1; pnodos.second=Nodo2;
    pos.first=Pos1; pos.second=Pos2;
    
    
    p.first=pnodos; p.second=pos;
    return p;
}

pair< pair<Node*, Node*>  , pair<int, int> > PhylogeneticMutation::NNI(Node * NodoSel, pair<int, int> pos){
    
    pair<Node*, Node*> pnodos;
    pair <pair<Node*, Node*>  , pair<int, int> > p;
    
    Node * Nodo1;
    Node * Nodo2;
    int Pos1, Pos2;

    Pos1 = pos.first;
    Pos2 = pos.second;


    Nodo1=  NodoSel->getSon(0)->getSon(Pos1);
    Nodo2=  NodoSel->getSon(1)->getSon(Pos2);

    NodoSel->getSon(0)->setSon(Pos1,Nodo2);
    NodoSel->getSon(1)->setSon(Pos2,Nodo1);

    pnodos.first=Nodo1; pnodos.second=Nodo2;
    
    
    p.first=pnodos; p.second=pos;
    return p;
}



void PhylogeneticMutation::NNIReverse(Node * NodoA, Node * NodoB){
    
    Node * PadreA;
    Node * PadreB;
    int Pos1, Pos2;
    
    PadreB = NodoB->getFather();      PadreA = NodoA->getFather();
    Pos1=PadreB->getSonPosition(NodoB);    Pos2=PadreA->getSonPosition(NodoA);
    PadreB->setSon(Pos1, NodoA);    PadreA->setSon(Pos2 , NodoB);


}


string PhylogeneticMutation:: getBrachNameProperty(int idnode,vector<Node*> nodos){
  int pos = 0;
  stringstream ss;
  
  while (pos < nodos.size() && nodos[pos]->getId() != idnode) pos++;
  
  if (pos < nodos.size()) {
      ss<<pos; 
      return "BrLen" + ss.str() ;
  } else 
      return "";
}

void PhylogeneticMutation::ModificarRamasDistGamma(Solution * solution){
    
    /*Also modifies branch lengths in 	order to improve the tree likelihood value.
    * Some branches, chosen at random, have their
    * lengths multiplied by a factor obtained from a Γ-distribution (Lewis, 1998)
    */
    
    TreeTemplate<Node> * tree = ((PhyloTree*) solution->getDecisionVariables()[0])->getTree();
    
    //if( PseudoRandom::randDouble() > 0.34 ){
	 double gamma; double distance;
	 vector<Node *> nodes = tree->getNodes();
	 for(unsigned int i = 0; i < nodes.size(); i++){
             if (PseudoRandom::randDouble() <= 0.5) {
                if (nodes[i]->hasDistanceToFather()){
			 distance = nodes[i]->getDistanceToFather();
        		 gamma =  gsl_ran_gamma (random_gsl, randomgsl_alpha, (1.0/randomgsl_alpha) );
			 if (distance * gamma != 0)	 nodes[i]->setDistanceToFather(distance * gamma);
		 }
             }
	}
   // }
    
}
		
/**Retorna vector de double con las 3 ramas Optimizadas, en el mismo orden en que fuen enviadas con las NamRamas de los NodeIds*/
double * PhylogeneticMutation::OptimizarRamasAfterSRP(TreeTemplate<Node> * tree, PhyloTree * Pt, vector<string> Ramas, Phylogeny * p, int NumEvals , double Tolerancia){

     clock_t t_ini;
    t_ini = clock(); 
    
    double * brOptimizadas = new double[4] ;
    
    //SubstitutionModel * Model = new HKY85(p->alphabet,Pt->kappa, Pt->piA, Pt->piC, Pt->piG, Pt->piT); 
     SubstitutionModel * Model = new GTR(p->alphabet,
           Pt->CT/Pt->AG,Pt->AT/Pt->AG,Pt->GT/Pt->AG,Pt->AC/Pt->AG,Pt->CG/Pt->AG,
           Pt->piA, Pt->piC, Pt->piG, Pt->piT); 
    
    DiscreteDistribution * RateDist =  new GammaDiscreteDistribution(p->NumCat,Pt->alpha,Pt->beta);
   
    RHomogeneousTreeLikelihood * tl1= new RHomogeneousTreeLikelihood(*tree, *p->sites2_, Model, RateDist, true,false,true);
    tl1->initialize();

    double lk= tl1->getValue();
    //cout << "Likelihood I " << lk << endl;
     
    tl1->enableFirstOrderDerivatives(true);
    tl1->enableSecondOrderDerivatives(true);
   
   ParameterList pl = tl1->getBranchLengthsParameters();
   ParameterList ps;
   for(int k=0;k<Ramas.size();k++){
       if (pl.hasParameter(Ramas[k])){
            ps.addParameter(pl.getParameter(Ramas[k]));
            //cout << "Rama " << k  << " dentro de BarnchLengtParams de Lik de Opt " << pl.getParameter(Ramas[k]).getName() << " " << pl.getParameter(Ramas[k]).getValue() << endl;
       }else{ //Esto No debria pasar
           cout << "UNA RAMA NO ESTA EN LAS BRACHNLENGHPARAMETR DEL LIK DEL OPTIMIZER" << endl;
           delete tl1;
           brOptimizadas[0]=0; brOptimizadas[1]=0; brOptimizadas[2]=0;
           return brOptimizadas;
       }
   }
   
   //cout << "Parametros A Mejorar " << endl;
   //for(int k=0;k<ps.size();k++){       cout <<  ps[k].getName() << " " << ps[k].getValue() << endl;   }
   
   
   Optimizer* optimizer;
   //optimizer =new ConjugateGradientMultiDimensions(tl1);
   optimizer = new PseudoNewtonOptimizer(tl1);
   optimizer->setMaximumNumberOfEvaluations(NumEvals);
   optimizer->getStopCondition()->setTolerance(Tolerancia);
   optimizer->setProfiler(NULL);
   optimizer->setMessageHandler(NULL);
   optimizer->setVerbose(0);
   optimizer->setConstraintPolicy(AutoParameter::CONSTRAINTS_AUTO);

   optimizer->init(ps);
   brOptimizadas[0] = optimizer->optimize();

   
   //cout <<" F " << brOptimizadas[0] << endl;

   pl=optimizer->getParameters();
   
   //cout << "Parametros Mejorados " << endl;
   //for(int k=0;k<pl.size();k++){       cout <<  pl[k].getName() << " " << pl[k].getValue() << endl;   }
   
   brOptimizadas[1] = pl[0].getValue(); brOptimizadas[2] = pl[1].getValue(); brOptimizadas[3] = pl[2].getValue();

   
   ComportamientoTime <<  ((double) (clock() - t_ini))/ CLOCKS_PER_SEC << endl; 
   ComportamientoML << lk - brOptimizadas[0]   << endl; 
   
   delete optimizer;
   //delete tree;
   //tree = new TreeTemplate<Node>(tl1->getTree());
   delete tl1;
   delete Model;
   delete RateDist;
   
   
   

   return brOptimizadas;
}

double PhylogeneticMutation::OptimizarRamas(TreeTemplate<Node> * &tree, PhyloTree* Pt, Phylogeny * p, double NumEvals , double Tolerancia){

    if(!OptRamas) return 0;
    
    clock_t t_ini;
    t_ini = clock();     
    
    //SubstitutionModel * Model = new HKY85(p->alphabet,Pt->kappa, Pt->piA, Pt->piC, Pt->piG, Pt->piT); 
    SubstitutionModel * Model = new GTR(p->alphabet,
           Pt->CT/Pt->AG,Pt->AT/Pt->AG,Pt->GT/Pt->AG,Pt->AC/Pt->AG,Pt->CG/Pt->AG,
           Pt->piA, Pt->piC, Pt->piG, Pt->piT); 

    DiscreteDistribution * RateDist =  new GammaDiscreteDistribution(p->NumCat,Pt->alpha,Pt->beta);
    
    RHomogeneousTreeLikelihood * tl1= new RHomogeneousTreeLikelihood(*tree, *p->sites2_, Model, RateDist, true,false,true);
    tl1->initialize();

    double lk1= tl1->getValue();
    cout << "Likelihood I " << lk1 ;
    
    tl1->enableFirstOrderDerivatives(true);
    tl1->enableSecondOrderDerivatives(true);
   
   ParameterList pl = tl1->getBranchLengthsParameters();
       
   Optimizer* optimizer;
   //optimizer =new ConjugateGradientMultiDimensions(tl1);
   //optimizer =new BfgsMultiDimensions(tl1);
   optimizer = new PseudoNewtonOptimizer(tl1);
   optimizer->setMaximumNumberOfEvaluations(NumEvals);
   optimizer->getStopCondition()->setTolerance(Tolerancia);
   optimizer->setProfiler(NULL);
   optimizer->setMessageHandler(NULL);
   optimizer->setVerbose(0);
   optimizer->setConstraintPolicy(AutoParameter::CONSTRAINTS_AUTO);

   optimizer->init(pl);
   double lk= optimizer->optimize();
   
   cout << " F " << lk  << " Mejora: " << lk1 - lk;
   
   TreeTemplate<Node>*  tLik = tl1->getTreeP_();
   vector<Node *> nodos= tree->getNodes();
   vector<Node *> nodos2= tLik->getNodes();
   Node * nodo; 
   Node * nodo2;
  
   if(nodos.size()!=nodos2.size()) { 
       cout << endl << "Número Nodos diferentes Tree " << nodos.size() << " TLik " << nodos2.size() << endl;
       
       delete tree;
       tree = new TreeTemplate<Node>();
       tree ->setRootNode(TreeTemplateTools::cloneSubtree<Node>(*tLik->getRootNode()));
            
       //Newick * newickprinttree = new Newick;
       //newickprinttree->write(*tree,"tree");
       //newickprinttree->write(*tLik,"tlik");
      //delete newickprinttree;
       
   }else{
       
        for(int i=0;i<nodos.size();i++){
           nodo=nodos[i]; nodo2=nodos2[i];
           if(nodo2->hasDistanceToFather())
                nodo->setDistanceToFather(nodo2->getDistanceToFather());
           else
             nodo->deleteDistanceToFather();
        }
   }
   
    
   //ComportamientoTime <<  ((double) (clock() - t_ini))/ CLOCKS_PER_SEC << endl; 
   //ComportamientoML << lk1 - lk   << endl; 
   
   
   cout <<" Tiempo " << ((double) (clock() - t_ini))/ CLOCKS_PER_SEC  << endl;
   
   delete optimizer;
   delete tl1;
   delete Model;
   delete RateDist;

   return lk;
}

double PhylogeneticMutation::OptimizarRamas(Solution * solution){

    if(!OptRamas) return 0;
    
    Phylogeny * Prob = (Phylogeny *) solution->getProblem();
    PhyloTree * Pt  = (PhyloTree*) solution->getDecisionVariables()[0];
    TreeTemplate<Node> * t;  
    t = Pt->getTree();
    
    return  OptimizarRamas(t, Pt, Prob,  NumIterOptRamas, TolerenciaOptRamas);
    
}



double PhylogeneticMutation::OptimizarParamModeloSust(Solution * solution){

    if(!OptimizacionSubstModel) return 0;
    
   // cout <<"============================================================" << endl;
    Phylogeny * Prob = (Phylogeny *) solution->getProblem();
    PhyloTree * Pt  = (PhyloTree*) solution->getDecisionVariables()[0];
    TreeTemplate<Node> * t;  
    t = Pt->getTree();
    
    
   //SubstitutionModel * Model = new HKY85(Prob->alphabet,Pt->kappa, Pt->piA, Pt->piC, Pt->piG, Pt->piT); 
   SubstitutionModel * Model = new GTR(Prob->alphabet,
           Pt->CT/Pt->AG,Pt->AT/Pt->AG,Pt->GT/Pt->AG,Pt->AC/Pt->AG,Pt->CG/Pt->AG,
           Pt->piA, Pt->piC, Pt->piG, Pt->piT); 

   DiscreteDistribution * RateDist =  new GammaDiscreteDistribution(Prob->NumCat,Pt->alpha,Pt->beta);
      
    DiscreteRatesAcrossSitesTreeLikelihood * tl1= new RHomogeneousTreeLikelihood(*t, *Prob->sites2_,Model, RateDist, true,false,true);
    tl1->initialize();

    double lk= tl1->getValue();

    DerivableSecondOrder* f = tl1;
    MetaOptimizerInfos* desc = new MetaOptimizerInfos();
    MetaOptimizer* poptimizer = 0;
         //  if (MetodoOptimizacionSubstModel == OptimizationTools::OPTIMIZATION_BRENT){
               
               ParameterList plsm = tl1->getSubstitutionModelParameters();
               desc->addOptimizer("Substitution model parameter", new SimpleMultiDimensions(f), plsm.getParameterNames(), 0, MetaOptimizerInfos::IT_TYPE_STEP);
     
                //for(int m=0;m<plsm.size();m++){ cout << "Par " << m << " " << plsm[m].getName() << " " << plsm[m].getValue() << endl;}
               
               ParameterList plrd = tl1->getRateDistributionParameters();
               desc->addOptimizer("Rate distribution parameter", new SimpleMultiDimensions(f), plrd.getParameterNames(), 0, MetaOptimizerInfos::IT_TYPE_STEP);
     
                //for(int m=0;m<plrd.size();m++){cout << "Par " << m << " " << plrd[m].getName() << " " << plrd[m].getValue() << endl;}
               
               poptimizer = new MetaOptimizer(f, desc, 0);
               
          /* }   else if (MetodoOptOtrosParam == OptimizationTools::OPTIMIZATION_BFGS){
     
               vector<string> vNameDer;
               AbstractNumericalDerivative* fnum = new ThreePointsNumericalDerivative(f);
               
               ParameterList plsm = tl->getSubstitutionModelParameters();
               vNameDer = plsm.getParameterNames();
          
               ParameterList plrd = tl->getRateDistributionParameters();
               vector<string> vNameDer2 = plrd.getParameterNames();

               vNameDer.insert(vNameDer.begin(), vNameDer2.begin(), vNameDer2.end());
               fnum->setParametersToDerivate(vNameDer);
 
              desc->addOptimizer("Rate & model distribution parameters", new BfgsMultiDimensions(fnum), vNameDer, 1, MetaOptimizerInfos::IT_TYPE_FULL);
              poptimizer = new MetaOptimizer(fnum, desc, 0);
        }
    
        }else {
             
        }*/

        poptimizer->setVerbose(0);
        poptimizer->setMaximumNumberOfEvaluations(NumIterOptSubstModel);
        poptimizer->getStopCondition()->setTolerance(TolerenciaOptSubstModel);
        
        poptimizer->setProfiler(NULL);
        poptimizer->setMessageHandler(NULL);
  
        poptimizer->setConstraintPolicy(AutoParameter::CONSTRAINTS_AUTO);
        
        ParameterList pl2 = plsm;
        pl2.addParameters(plrd);
        
        poptimizer->init(pl2); //tl1->getParameters()
        
        double lk2=poptimizer->optimize();
        cout << "Optimización SubstModel Lik " << lk << " OptimiLik " <<  lk2 << " Mejoramiento " << lk-lk2<< endl;
        
        ParameterList pl = poptimizer->getParameters();
        //for(int m=0;m<pl.size();m++){ cout << "Par " << m << " " << pl[m].getName() << " " << pl[m].getValue() << endl;      }
        //cout << "NumberOfEvaluations " << poptimizer->getNumberOfEvaluations() << endl;
   
       double theta_  = pl.hasParameter("GTR.theta")?pl.getParameterValue("GTR.theta"):0;
       double theta1_ = pl.hasParameter("GTR.theta1")?pl.getParameterValue("GTR.theta1"):0;
       double theta2_ = pl.hasParameter("GTR.theta2")?pl.getParameterValue("GTR.theta2"):0;

        if(theta_!=0 and theta1_!=0 and theta2_!=0){
            Pt->piA = theta1_ * (1. - theta_);
            Pt->piC = (1. - theta2_) * theta_;
            Pt->piG = theta2_ * theta_;
            Pt->piT =(1. - theta1_) * (1. - theta_);
        }
    
        Pt->CT= pl.getParameterValue("GTR.a")*Pt->AG;
        Pt->AT= pl.getParameterValue("GTR.b")*Pt->AG;       
        Pt->GT= pl.getParameterValue("GTR.c")*Pt->AG;
        Pt->AC= pl.getParameterValue("GTR.d")*Pt->AG;
        Pt->CG= pl.getParameterValue("GTR.e")*Pt->AG;
       
        if(pl.hasParameter("Gamma.alpha"))  Pt->alpha = pl.getParameterValue("Gamma.alpha");
        if(pl.hasParameter("Gamma.beta"))  Pt->beta = pl.getParameterValue("Gamma.beta");
    
         
         delete tl1;
         delete Model;
         delete RateDist;
         delete poptimizer;
        
         //cout <<"============================================================" << endl;
         return lk2;
       
}

/************** DEMORA UN MUNDO (186 Y 218) PARA HACER EN CADA ITERACION *****************/
double PhylogeneticMutation::OptimizarRamasyParamModeloSust(Solution * solution){

    if(!OptimizacionSubstModel and !OptRamas) return 0;
    
    clock_t t_ini;
    t_ini = clock(); 
    
    Phylogeny * Prob = (Phylogeny *) solution->getProblem();
    PhyloTree * Pt  = (PhyloTree*) solution->getDecisionVariables()[0];
    TreeTemplate<Node> * t;  
    t = Pt->getTree();
    
    
   //SubstitutionModel * Model = new HKY85(Prob->alphabet,Pt->kappa, Pt->piA, Pt->piC, Pt->piG, Pt->piT); 
   SubstitutionModel * Model = new GTR(Prob->alphabet,
           Pt->CT/Pt->AG,Pt->AT/Pt->AG,Pt->GT/Pt->AG,Pt->AC/Pt->AG,Pt->CG/Pt->AG,
           Pt->piA, Pt->piC, Pt->piG, Pt->piT); 
   DiscreteDistribution * RateDist =  new GammaDiscreteDistribution(Prob->NumCat,Pt->alpha,Pt->beta);
      
    RHomogeneousTreeLikelihood * tl= new RHomogeneousTreeLikelihood(*t, *Prob->sites2_,Model, RateDist, true,false,true);
    tl->initialize();

    double lk= tl->getValue();
    
    
     DerivableSecondOrder* f = tl;
     ParameterList pl; // = tl->getParameters();
     MetaOptimizerInfos* desc = new MetaOptimizerInfos();
     MetaOptimizer* poptimizer = 0;
     //AbstractNumericalDerivative* fnum = new ThreePointsNumericalDerivative(f);

      if(OptRamas){

      if (MetodoOptRamas == OptimizationTools::OPTIMIZATION_GRADIENT)
           desc->addOptimizer("Branch length parameters", new ConjugateGradientMultiDimensions(f), tl->getBranchLengthsParameters().getParameterNames(), 2, MetaOptimizerInfos::IT_TYPE_FULL);
      else if (MetodoOptRamas == OptimizationTools::OPTIMIZATION_NEWTON)
           desc->addOptimizer("Branch length parameters", new PseudoNewtonOptimizer(f), tl->getBranchLengthsParameters().getParameterNames(), 2, MetaOptimizerInfos::IT_TYPE_FULL);
      else if (MetodoOptRamas == OptimizationTools::OPTIMIZATION_BFGS)
           desc->addOptimizer("Branch length parameters", new BfgsMultiDimensions(f), tl->getBranchLengthsParameters().getParameterNames(), 2, MetaOptimizerInfos::IT_TYPE_FULL);

      pl.addParameters(tl->getBranchLengthsParameters());
    }
     
     if(OptimizacionSubstModel){
    // if (optMethodModel == OPTIMIZATION_BRENT)
    //{
       ParameterList plsm = tl->getSubstitutionModelParameters();
       desc->addOptimizer("Substitution model parameter", new SimpleMultiDimensions(f), plsm.getParameterNames(), 0, MetaOptimizerInfos::IT_TYPE_STEP);
       //for(int m=0;m<plsm.size();m++){ cout << "Par " << m << " " << plsm[m].getName() << " " << plsm[m].getValue() << endl;   }

      ParameterList plrd =tl->getRateDistributionParameters();
      desc->addOptimizer("Rate distribution parameter", new SimpleMultiDimensions(f), plrd.getParameterNames(), 0, MetaOptimizerInfos::IT_TYPE_STEP);
      //for(int m=0;m<plrd.size();m++){ cout << "Par " << m << " " << plrd[m].getName() << " " << plrd[m].getValue() << endl;}
      
     //}
     /*else if (optMethodModel == OPTIMIZATION_BFGS)
     {
       vector<string> vNameDer;
   
       ParameterList plsm = parameters.getCommonParametersWith(tl->getSubstitutionModelParameters());
       vNameDer = plsm.getParameterNames();
   
       ParameterList plrd = parameters.getCommonParametersWith(tl->getRateDistributionParameters());
   
       vector<string> vNameDer2 = plrd.getParameterNames();
   
       vNameDer.insert(vNameDer.begin(), vNameDer2.begin(), vNameDer2.end());
       fnum->setParametersToDerivate(vNameDer);
   
       desc->addOptimizer("Rate & model distribution parameters", new BfgsMultiDimensions(fnum), vNameDer, 1, MetaOptimizerInfos::IT_TYPE_FULL);
       poptimizer = new MetaOptimizer(fnum, desc, nstep);
     }*/
      
      pl.addParameters(plsm); pl.addParameters(plrd);
    }
     
    poptimizer = new MetaOptimizer(f, desc, 0);
     
    poptimizer->setVerbose(0); poptimizer->setProfiler(NULL); poptimizer->setMessageHandler(NULL);
    poptimizer->setMaximumNumberOfEvaluations(NumIterOptRamas);
    poptimizer->getStopCondition()->setTolerance(TolerenciaOptRamas);
   
  
    poptimizer->setConstraintPolicy(AutoParameter::CONSTRAINTS_AUTO);
    poptimizer->init(pl);
    double lk2=poptimizer->optimize();
    //cout << " Likelihood I " << lk << " Optimi Lik " <<  lk2 << " Diferencia " << lk-lk2<< endl;
    cout << " Likelihood I " << lk << endl;
   
    pl = poptimizer->getParameters();
    //for(int m=0;m<pl.size();m++){  cout << "Par " << m << " " << pl[m].getName() << " " << pl[m].getValue() << endl;     }
   
    
    double theta_  = pl.hasParameter("GTR.theta")?pl.getParameterValue("GTR.theta"):0;
    double theta1_ = pl.hasParameter("GTR.theta1")?pl.getParameterValue("GTR.theta1"):0;
    double theta2_ = pl.hasParameter("GTR.theta2")?pl.getParameterValue("GTR.theta2"):0;

    if(theta_!=0 and theta1_!=0 and theta2_!=0){
        Pt->piA = theta1_ * (1. - theta_);
        Pt->piC = (1. - theta2_) * theta_;
        Pt->piG = theta2_ * theta_;
        Pt->piT =(1. - theta1_) * (1. - theta_);
    }
    
    Pt->CT= pl.getParameterValue("GTR.a")*Pt->AG;
    Pt->AT= pl.getParameterValue("GTR.b")*Pt->AG;
    Pt->GT= pl.getParameterValue("GTR.c")*Pt->AG;
    Pt->AC= pl.getParameterValue("GTR.d")*Pt->AG;
    Pt->CG= pl.getParameterValue("GTR.e")*Pt->AG;
       
         

    //if(pl.hasParameter("GTR.kappa"))  Pt->kappa = pl.getParameterValue("GTR.kappa");
    if(pl.hasParameter("Gamma.alpha"))  Pt->alpha = pl.getParameterValue("Gamma.alpha");
    if(pl.hasParameter("Gamma.beta"))  Pt->beta = pl.getParameterValue("Gamma.beta");
         
         
     TreeTemplate<Node>*  tLik = tl->getTreeP_();
     vector<Node *> nodos= t->getNodes();
     vector<Node *> nodos2= tLik->getNodes();
     Node * nodo; 
     Node * nodo2;
     
     if(nodos.size()!=nodos2.size()) { 
       cout << "Número Nodos diferentes Tree " << nodos.size() << " TLik " << nodos2.size() << endl;
       
       delete t;
       t = new TreeTemplate<Node>();
       t ->setRootNode(TreeTemplateTools::cloneSubtree<Node>(*tLik->getRootNode()));
            
       //Newick * newickprinttree = new Newick;
       //newickprinttree->write(*tree,"tree");
       //newickprinttree->write(*tLik,"tlik");
      //delete newickprinttree;
       
   }else{

         for(int i=0;i<nodos.size();i++){
            nodo=nodos[i]; nodo2=nodos2[i];
            if(nodo2->hasDistanceToFather())
                nodo->setDistanceToFather(nodo2->getDistanceToFather());
            else
                nodo->deleteDistanceToFather();
         }
   }
         
    //p1->setModel(); p1->setRateDistribution();
    //Prob->evaluate(solution);
    //cout << "Evaluado 2 " << solution->getObjective(1) << " y Evaluador por el Optimi " << lk2 << endl;
         
     delete tl;
     delete Model;
     delete RateDist;
     delete poptimizer;

     ComportamientoTime <<  ((double) (clock() - t_ini))/ CLOCKS_PER_SEC << endl; 
     ComportamientoML << lk - lk2   << endl; 
   
     return lk2;
     
     
       
}

pair< pair<double *, int *>, Node *> PhylogeneticMutation::SPR(Node * Nodo1, Node * Nodo2, int &NextIDNode){
    
    pair<pair<double *, int *>,Node*> p;
    int PosNodo;
    double distancetofather=0;
    double * b = new double[5]; //0 tipo, 1 brLenHermano, 2 brLenNodo2, 3 brLenNod1, 4 brLenPadre
    int * IDs = new int[3];  //0 IDNodoPadre, 1 IDNodo1, 2 IDNodo2
    Node * Padre;
    Node * Padre2;
    Node * GP;
    Node * Hermano;
  
    Padre=Nodo1->getFather();
    if (Nodo1->hasDistanceToFather()) b[3] = Nodo1->getDistanceToFather(); else b[3] =0 ;

    if(Padre->getNumberOfSons()==2){ //Si tiene 2 hijos Collapse Brother por Father
       PosNodo= Padre->getSonPosition(Nodo1);
       Hermano = Padre->getSon(PosNodo==0?1:0);

       //cout << "Hermano " << endl;
       if (Hermano->hasDistanceToFather()) {
           distancetofather = Hermano->getDistanceToFather();
           b[1] = distancetofather;
       }else      
           b[1] = 0;
       

       //Quito al Padre sin el hermano, y ubico al hermano en vez del Padre
       Padre->removeSon(Hermano);
       GP = Padre->getFather();
       GP->setSon(GP->getSonPosition(Padre),Hermano);
       
       //cout << "Set Son Hermano" << endl;

       if(Padre->hasDistanceToFather()) {
               distancetofather+=Padre->getDistanceToFather();
               b[4] = Padre->getDistanceToFather();
       }else b[4] =0;
           
       Hermano->setDistanceToFather(distancetofather);
       
       //cout << " Hermano 3" << endl;       
       
       b[0] = 1; //Normal Nodos con dos Hijos
       p.second=Hermano;
      

     }else{ //Si tiene mas de un hermano, no se hace Collapse

       PosNodo= Padre->getSonPosition(Nodo1);
       Hermano = Padre->getSon(PosNodo==0?1:0);

       //cout << "Hermano 2" << endl;
       
       Padre->removeSon(Nodo1); //NO Elimina el NODO solo lo eliminar dle Vector de Sons

       Padre = new Node(NextIDNode++);
       Padre->addSon(Nodo1);
       
       b[0] = 2; //Nodo con mas de 2 Hijos SPRReverse
       p.second=Hermano;
     }

     distancetofather=0;
     
     Padre2 = Nodo2->getFather();
     
     //cout << "Hermano 1" << endl;
     
     if(Nodo2->hasDistanceToFather()) {
         distancetofather = Nodo2->getDistanceToFather();
         b[2]=distancetofather;
     }else   b[2]=0;
     
     
     
     //cout << "PAdre " << endl;

     Padre2->setSon(Padre2->getSonPosition(Nodo2),Padre);
     
     Padre->setDistanceToFather(distancetofather/2);
     
     //cout << "PAdre2 " << endl;

     //Agrego al Nodo2 como hijo del Padre
     Padre->addSon(Nodo2);
     
     Nodo2->setDistanceToFather(distancetofather/2);
     //cout << "PAdre 3 " << endl;
     
     //cout << "Herman ID " << Hermano->getId() << endl;
     IDs[0] = Padre->getId();      IDs[1] = Nodo1->getId();     IDs[2] = Nodo2->getId();
     
     /*if(Padre->hasDistanceToFather() and Nodo1->hasDistanceToFather() and Nodo2->hasDistanceToFather())
        if(Padre->getDistanceToFather()>0 and Nodo1->getDistanceToFather()>0 and Nodo2->getDistanceToFather()>0)
        cout << "Ramas a Optimizar dentro SPR " << Padre->getDistanceToFather() << " - " << Nodo1->getDistanceToFather() << " - " << Nodo2->getDistanceToFather() << endl;
     */
     pair<double *, int *> pn;
     pn.first=b; pn.second=IDs;
     
     p.first = pn;
     return p;
}

//SPR de Reserva a estado Anterior
void PhylogeneticMutation::SPR(Node * Nodo1, Node * Nodo2, double *b){
    
   //b -- 0 tipo, 1 brLenHermano, 2 brLenNodo2, 3 brLenNod1, 4 brLenPadre
    int PosNodo;
    Node * Padre;
    Node * Padre2;
    Node * GP;
    Node * Hermano;
  
    Padre=Nodo1->getFather();
    if (b[3]!= 0) Nodo1->setDistanceToFather(b[3]);

    PosNodo= Padre->getSonPosition(Nodo1);
   Hermano = Padre->getSon(PosNodo==0?1:0);
   if (b[2]!= 0) Hermano->setDistanceToFather(b[2]);

   //cout << "Hermano " << endl;

   //Quito al Padre sin el hermano, y ubico al hermano en vez del Padre
   Padre->removeSon(Hermano);
   GP = Padre->getFather();
   GP->setSon(GP->getSonPosition(Padre),Hermano);

   //cout << "Set Son Hermano" << endl;

  Padre2 = Nodo2->getFather();
     
  //cout << "PAdre " << endl;

   Padre2->setSon(Padre2->getSonPosition(Nodo2),Padre);
   if(b[4] != 0) Padre->setDistanceToFather(b[4]);

   //cout << "PAdre2 " << endl;

   //Agrego al Nodo2 como hijo del Padre
   Padre->addSon(Nodo2);
   if(b[1] != 0) Nodo2->setDistanceToFather(b[1]);
     //cout << "PAdre 3 " << endl;
     
     //cout << "Herman ID " << Hermano->getId() << endl;
      
}

void PhylogeneticMutation::SPRreverse(Node * Nodo1, Node * Nodo2 , double *b,int &NextIDNode){
    
    int PosNodo;
    Node * Padre;
    Node * Padre2;
    Node * GP;
    Node * Hermano;
  
    Padre=Nodo1->getFather();
    

    PosNodo= Padre->getSonPosition(Nodo1);
    Hermano = Padre->getSon(PosNodo==0?1:0);
    if (b[2]!= 0) Hermano->setDistanceToFather(b[2]);
   
     //Quito al Padre sin el hermano, y ubico al hermano en vez del Padre
     Padre->removeSon(Hermano);
     GP = Padre->getFather();
     GP->setSon(GP->getSonPosition(Padre),Hermano);


     delete Padre; NextIDNode--;
     Padre2 = Nodo2->getFather();
     //Agrego al Nodo2 como hijo del Padre
     Padre2->addSon(Nodo1);
     if (b[3]!= 0) Nodo1->setDistanceToFather(b[3]);
     //Nodo1->setDistanceToFather(distancetofather/2);
}


   
int PhylogeneticMutation::getNivel(Node* nodo){
    int Max=-1;
      
    if(nodo->isLeaf()){
        return 0;
    }else{
        
        vector<int> V;
        for(int i=0;i<nodo->getNumberOfSons();i++){
            V.push_back(getNivel(nodo->getSon(i)));
        }
        for(int i=0;i<nodo->getNumberOfSons();i++){
            if(V[i]>Max) Max=V[i];
        }
        return Max+1;
    }
}

int  PhylogeneticMutation::SPRvalide (Node* N1, Node* N2) {
    if (!N2->hasFather()) return 0;
    if (N1->getFather()==N2->getFather()) return 0;
    if (N1->getFather()==N2) return 0;
    
    return 1;
}


void * PhylogeneticMutation::execute(void *object) {
  Solution *solution = (Solution *)object;
  // TODO: VALID_TYPES?
  //double probability = *(double *)getParameter("probability");
  doMutation(mutationProbability_, solution);
  return solution;
} // execute
 