//  PhylogeneticMutation.cpp
//
//  Author:
//       Cristian G. Zambrano Vega <cristian_uteq@hotmail.com>
//
//  Copyright (c) 2011 Antonio J. Nebro, Juan J. Durillo
//
//  This program is free software: you can redistribute it and/or modify
//  it under the terms of the GNU Lesser General Public License as published by
//  the Free Software Foundation, either version 3 of the License, or
//  (at your option) any later version.
//
//  This program is distributed in the hope that it will be useful,
//  but WITHOUT ANY WARRANTY; without even the implied warranty of
//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//  GNU Lesser General Public License for more details.
//
//  You should have received a copy of the GNU Lesser General Public License
//  along with this program.  If not, see <http://www.gnu.org/licenses/>.

#include <PhylogeneticMutation.h>


/**
 * Constructor
 * Creates a new instance of the SPR mutation operator
 */
PhylogeneticMutation::PhylogeneticMutation(map<string, void *> parameters)
: Mutation(parameters) {

   mutationProbability_=0;  Metodo="NNI";
    
   string NumExp = *(string *) parameters["NumExp"];
   if (parameters["metodo"] != NULL)              Metodo = *(string *) parameters["metodo"];
   if (parameters["probability"] != NULL)         mutationProbability_ = *(double *) parameters["probability"];
   if (parameters["NumIteracionesPPN"] != NULL)   NumIteraciones  = *(int *) parameters["NumIteracionesPPN"];
   
   
   if (parameters["optramas"] != NULL)            OptRamas  = *(bool *) parameters["optramas"];
   if (parameters["MetodoOptRamas"] != NULL)      MetodoOptRamas  = *(string *) parameters["MetodoOptRamas"];
   if (parameters["NumIterOptRamas"] != NULL)     NumIterOptRamas  = *(int *) parameters["NumIterOptRamas"];
   if (parameters["TolerenciaOptRamas"] != NULL)  TolerenciaOptRamas  = *(double *) parameters["TolerenciaOptRamas"];

   if (parameters["OptimizacionSubstModel"] != NULL)  OptimizacionSubstModel  = *(bool *) parameters["OptimizacionSubstModel"];
   if (parameters["MetodoOptimizacionSubstModel"] != NULL) MetodoOptimizacionSubstModel  = *(string *) parameters["MetodoOptimizacionSubstModel"];
   if (parameters["NumIterOptSubstModel"] != NULL)     NumIterOptSubstModel  = *(int *) parameters["NumIterOptSubstModel"];
   if (parameters["TolerenciaOptSubstModel"] != NULL)  TolerenciaOptSubstModel  = *(double *) parameters["TolerenciaOptSubstModel"];


   if (parameters["OptimizacionRateDist"] != NULL)  OptimizacionRateDist  = *(bool *) parameters["OptimizacionRateDist"];
   if (parameters["MetodoOptRateDistB"] != NULL)    MetodoOptRateDistB  = *(string *) parameters["MetodoOptRateDistB"];
   
   
   
   random_gsl = gsl_rng_alloc(gsl_rng_default);
   randomgsl_alpha = 500;
   
   
   comparator = new DominanceComparator();
   
   //std::strcpy(NumExp,"ComportamientoML");
   ComportamientoML.open("ComportamientoML"); ComportamientoTime.open("ComportamientoTime");
  
   
} // PhylogeneticMutation



void PhylogeneticMutation::printParameters(){
   
   cout << "************** Mutation Operator Parameters ************ " << endl;
   cout << "mutationProbability: " << mutationProbability_ << endl;
  
   cout << "Método de Mutación: " <<  Metodo << endl;
   cout << "Número de Iteraciones  " << NumIteraciones << endl;
   
   
   cout << "Optimización Ramas:  " <<  OptRamas << endl;
   if(OptRamas){
       cout << "Método Optimización Ramas: " <<  MetodoOptRamas << endl;
       cout << "Num Iteraciónes Opt. Ramas : " <<  NumIterOptRamas << endl;
       cout << "Tolerencia Opt. Ramas : " <<  TolerenciaOptRamas << endl;
   }
   
   cout << "Optimización Substitution Model:  " <<  OptimizacionSubstModel << endl;
   if(OptimizacionSubstModel){
       cout << "Método Optimización Substitution Model: " <<  MetodoOptimizacionSubstModel << endl;
       cout << "Num Iteraciónes Opt. Substitution Model: " <<  NumIterOptSubstModel << endl;
       cout << "Tolerencia Opt. Substitution Model : " <<  TolerenciaOptSubstModel << endl;
   }
   
    cout << "Optimización Rate Distribution:  " <<  OptimizacionRateDist << endl;
   if(OptimizacionRateDist){
       cout << "Método Optimización Rate Distribution: " <<  MetodoOptRateDistB << endl;
   }
   
   cout << endl;
}

/**
 * Destructor
 */
PhylogeneticMutation::~PhylogeneticMutation() { 

        ComportamientoML.close();	ComportamientoTime.close();
        
} // ~PhylogeneticMutation


/**
 * Perform the mutation operation
 * @param probability Mutation probability
 * @param solution The solution to mutate
 */
void * PhylogeneticMutation::doMutation(double mutationProbability_, Solution *solution) {
    
    if ( PseudoRandom::randDouble() <= mutationProbability_) {
        
                if(Metodo=="ppn") PPNOptimiz(solution); 
                else if(Metodo=="nni") NNIandBranchMutate(solution); 
                else if(Metodo=="spr") SPRPhyloMOEA(solution);
                else if(Metodo=="trb") TBR(solution);
                else   NNIMoves(solution); 
    }

    //if(OptRamas || OptModeloyTasaDist)  OptimizarRamasyParamModeloSust(solution);


} // doMutation

void PhylogeneticMutation::TBR(Solution * solution){
    vector<int> nodosIDs;
    Variable **variables = solution->getDecisionVariables();
    PhyloTree * Pt = (PhyloTree*) variables[0];
    TreeTemplate<Node> * tree = Pt->getTree();

    Node * nodo;
    Node * nodoi;
    Node * nodoj;
    Node * nodoPadre;
    Node * nodoSubTree;

    nodosIDs = tree->getNodesId();
    do{
              do{
                      nodo = tree->getNode(RandomTools::pickOne(nodosIDs,true));
              }while(nodo->isLeaf() || nodo->getNumberOfSons() < 2 || !nodo->hasFather());

              if (RandomTools::flipCoin()) {
                      nodoi= nodo->getSon(0); nodoj= nodo->getSon(1);
              }else{
                      nodoi= nodo->getSon(1); nodoj= nodo->getSon(0);
              }

     }while(nodoi->isLeaf());

     TreeTemplate<Node> * subtree = new TreeTemplate<Node>(nodoi);
     subtree->resetNodesId();
     nodosIDs = subtree->getNodesId();
     do{
            nodoSubTree = subtree->getNode(RandomTools::pickOne(nodosIDs,true));
     }while(nodoSubTree->isLeaf());

     subtree->rootAt(nodoSubTree->getId());

     nodoPadre = nodo->getFather();
     nodoPadre->setSon(nodoPadre->getSonPosition(nodo),nodoj);
     tree->resetNodesId();
     nodosIDs = tree->getNodesId();
     do{
              nodo = tree->getNode(RandomTools::pickOne(nodosIDs,true));
     }while(nodo->isLeaf());


     int posSon;
     if (RandomTools::flipCoin()) posSon=0; else posSon=1;

     Node * nuevonodo = new Node();
     nuevonodo->addSon(nodo->getSon(posSon));
     nuevonodo->addSon(subtree->getRootNode());

     nodo->setSon(posSon,nuevonodo);
     tree->resetNodesId();

}


void PhylogeneticMutation::SPRPhyloMOEA(Solution * solution){
    
 PhyloTree * Pt = (PhyloTree*) solution->getDecisionVariables()[0];
  TreeTemplate<Node> * tree = Pt->getTree();
  
  Node * Nodo1;
  Node * Nodo2;
  Node * Padre;
  Node * GP;
  Node * Hermano;
  int PosNodo;
  double distancetofather=0;

  bool b=true;
  vector<int> nodosIDs = tree->getNodesId();

  do{
      Nodo1 =  tree->getNode( nodosIDs[PseudoRandom::randInt(0, nodosIDs.size() - 1)]);
      if(Nodo1->hasFather()){
            Padre = Nodo1->getFather();
            //si tiene 2 Hijos por COllapse debe tener GP
            if(Padre->getNumberOfSons()==2) {
                if(Padre->hasFather()) b=false; //Se necesita GP para a este enlazr hermano
            }else b = false;
      }
  }while(b);

  if(Padre->getNumberOfSons()==2){ //Si tiene 2 hijos Collapse Brother por Father
    PosNodo= Padre->getSonPosition(Nodo1);
    Hermano = Padre->getSon(PosNodo==0?1:0);
    if (Hermano->hasDistanceToFather()) distancetofather = Hermano->getDistanceToFather();
    Padre->removeSon(Nodo1); //NO Elimina el NODO solo lo eliminar dle Vector de Sons
    Padre->removeSon(Hermano);

    GP = Padre->getFather();
    GP->setSon(GP->getSonPosition(Padre),Hermano);

    if(Padre->hasDistanceToFather()) distancetofather+=Padre->getDistanceToFather();
    Hermano->setDistanceToFather(distancetofather);

    delete Padre;

  }else{ //Si tiene mas de un hermano, no se hace Collapse
    Padre->removeSon(Nodo1); //NO Elimina el NODO solo lo eliminar dle Vector de Sons
    Hermano = NULL;
  }

  nodosIDs = tree->getNodesId();
  b=true;

  do{
        Nodo2 =  tree->getNode( nodosIDs[PseudoRandom::randInt(0, nodosIDs.size() - 1)]);
        if(Nodo2->hasFather()){
          if(Nodo2!=Hermano) b=false;
        }
  }while(b);

  Padre = Nodo2->getFather();
  distancetofather = Nodo2->getDistanceToFather();
  PosNodo= Padre->getSonPosition(Nodo2);

  Node * nodo = new Node();
  if(PosNodo==0){
    nodo->addSon(Nodo2); nodo->addSon(Nodo1);
  }else{
    nodo->addSon(Nodo1); nodo->addSon(Nodo2);
  }
  Nodo2->setDistanceToFather(distancetofather/2);

  //Agrego Nuevo Nodo al Padre
  Padre->setSon(PosNodo, nodo);
  nodo->setDistanceToFather(distancetofather/2);

  tree->resetNodesId(); //Uniion de otro subNodos se deben resetear ID

}

bool PhylogeneticMutation::NNIValidate(Node * Nodo){

    if (Nodo->getNumberOfSons()>1){
          if (!Nodo->getSon(0)->isLeaf() and !Nodo->getSon(1)->isLeaf()) return true;    
    }
    return false;

}


bool PhylogeneticMutation::NNIValidateBioPP(Node * Nodo){
    if (Nodo->hasFather()){
          if (Nodo->getFather()->hasFather()) return true;    
    }
    return false;

}

 void PhylogeneticMutation::NNIandBranchMutate(Solution * solution){
    
    //SPRPhyloMOEA(solution);
             
    PhyloTree * Pt = (PhyloTree*) solution->getDecisionVariables()[0];
    TreeTemplate<Node> * tree = Pt->getTree();

    Node * NodoSel;
    vector<Node *> nodes = tree->getNodes();

    do{
          NodoSel =  nodes[PseudoRandom::randInt(0, nodes.size() - 1)];
          
          
    }while(!NNIValidate(NodoSel));
    
    //cout << "Nodo Seleccion ID " << NodoSel->getId() << endl;
    NNI(NodoSel);
    
    
    
    double gamma; double distance;
    for(unsigned int i = 0; i < nodes.size(); i++){
           if (PseudoRandom::randDouble() <= 0.5) {
                if (nodes[i]->hasDistanceToFather()){
			 distance = nodes[i]->getDistanceToFather();
        		 gamma =  gsl_ran_gamma (random_gsl, randomgsl_alpha, (1.0/randomgsl_alpha) );
			 if (distance * gamma != 0)	 nodes[i]->setDistanceToFather(distance * gamma);
		 }
             }
     }
         
}

void PhylogeneticMutation::NNIMoves(Solution * solution){
    
    PhyloTree * Pt = (PhyloTree*) solution->getDecisionVariables()[0];
    TreeTemplate<Node> * tree = Pt->getTree();

    Node * NodoSel;
    vector<int> nodosIDs = tree->getNodesId();

    for(int i=0;i<nodosIDs.size();i++){
        if( PseudoRandom::randDouble()<0.5){
                NodoSel= tree->getNode( nodosIDs[i]);
                if(NNIValidate(NodoSel)) 
                         NNI(NodoSel);
        }
    }
}

void PhylogeneticMutation::NNIMovesLS(Solution * solution){
    cout <<"============================================================" << endl;
    cout << "Scores Inicial: " << solution->getObjective(0) << " Lik: " << solution->getObjective(1) << endl;

    PhyloTree * Pt = (PhyloTree*) solution->getDecisionVariables()[0];
    TreeTemplate<Node> * tree = Pt->getTree();
    Phylogeny * problem_ = (Phylogeny *) solution->getProblem();

    DRTreeParsimonyScore * Par =	new DRTreeParsimonyScore(*tree, *problem_->getSites() ,false,true);
    TreeTemplate<Node> * treeP = Par->getTreeP_();
  
    vector<Node*> nodes = treeP->getNodes();
    Node* node;
    
    bool NNIMoves=false;
    for(int i=0;i<nodes.size();i++){
        node = nodes[i];
        if(NNIValidateBioPP(node)){
            if(Par->testNNI(node->getId())  < 0){
                NNIMoves=true;
                Par->doNNI(node->getId());
                Par->topologyChangeTested(*new TopologyChangeEvent());
                cout << "Nuevo Score " << Par->getScore() << endl;
            }
        }
    }
    
    if(!NNIMoves){   
        cout << "No hay Mov NNI, aplica PPN" << endl;
        PPN_LSPar(solution);
    }else{
        Pt->setTree(new TreeTemplate<Node>(*treeP));
    }
    delete Par;
    problem_->evaluate(solution);
    cout << "Scores Final: " << solution->getObjective(0) << " Lik: " << solution->getObjective(1) << endl;
    cout <<"============================================================" << endl;
}



/*void PhylogeneticMutation::NNIMovesLS2(Solution * solution){
    cout <<"============================================================" << endl;
    cout << "Scores Inicial: " << solution->getObjective(0) << " Lik: " << solution->getObjective(1) << endl;

    PhyloTree * Pt = (PhyloTree*) solution->getDecisionVariables()[0];
    TreeTemplate<Node> * tree = Pt->getTree();
    Phylogeny * problem_ = (Phylogeny *) solution->getProblem();

    DRTreeParsimonyScore * Par =	new DRTreeParsimonyScore(*tree, *problem_->getSites() ,false,true);
    TreeTemplate<Node> * treeP = Par->getTreeP_();
  
    vector<Node*> nodes = treeP->getNodes();
    Node* node;
    
    pair<Node*, Node*> p;
    double BestPar = Par->getScore();
      
    bool NNIMoves=false;
    for(int i=0;i<nodes.size();i++){
        node = nodes[i];
        if(NNIValidate(node)){
            p=NNI(node);
            Par->topologyChangeTested(*new TopologyChangeEvent());
            if(Par->getScore() < BestPar){
                NNIMoves=true;
                BestPar = Par->getScore();
                cout << "Nuevo Score " << Par->getScore() << endl;
            }else{
                NNIReverse(p.first, p.second);
            }
        }
    }
    
    /*if(!NNIMoves){   
        cout << "No hay Mov NNI, aplica PPN" << endl;
        PPN_LSPar(solution);
    }else{
        Pt->setTree(new TreeTemplate<Node>(*treeP));
    //}
    delete Par;
    problem_->evaluate(solution);
    cout << "Scores Final: " << solution->getObjective(0) << " Lik: " << solution->getObjective(1) << endl;
    cout <<"============================================================" << endl;
}*/


bool PhylogeneticMutation::isMov(vector< pair<int , int > > vIDS, int IDN1, int IDN2){
    pair<int , int > eIDS;
     
    for (int i=0;i<vIDS.size();i++){
         eIDS = vIDS[i];
         if(eIDS.first == IDN1 and eIDS.second == IDN2)            return true;
    }
    return false;
}
/*
 Recorre las NIteraciones con SPR, y se queda con el que MENOR Parsimonia da, luego hace esl SPR Movimiento
 * y de parte del Max Likelihood optimiza las tres ramas SPR afectadas
 * Se supone que el mejor SPR es casi el Mejor LikeLikhood, pero igual ayudo al LikeliHood
 */

void PhylogeneticMutation::PPNOptimiz(Solution * solution){
    cout <<"============================================================" << endl;

    //Optimized Tree 
    PhyloTree * Pt = (PhyloTree*) solution->getDecisionVariables()[0];
    Phylogeny * problem_ = (Phylogeny *) solution->getProblem();
    TreeTemplate<Node> * tree = Pt->getTree();

    vector< pair<int , int > > MovSPRPar; //Almacena todos los MovsSPR ya hechos entres ID1 y ID2
    pair<int , int> IDs;        //Mejor Mov SPR ID1 ID2 
    
    pair<int , int> BestMovSPRPar;        //Mejor Mov SPR ID1 ID2 
    
    
    //DRTreeParsimony usado para denotar los posibles buenos moviemitos basads en Parsimonia
    DRTreeParsimonyScore * Par =	new DRTreeParsimonyScore(*tree, *problem_->getSites() ,false,true);
    TreeTemplate<Node> * treeP = Par->getTreeP_();
    vector<Node*> nodes = treeP->getNodes();
    int NextNodeIDPar = treeP->getNextId();

  
    int ParsimonyScore;
    int MenorParsimonia = Par->getScore();
    cout << "Parsimonia I " << MenorParsimonia << " ";
    
     
    Node * Root;
    Node* Nodo1;
    Node* Nodo2;

  int MaxNivel, dmax,d,up,down,u, Iteracion;
  bool b;
  
  pair< pair<double *, int *>, Node *> pPar;
  pair<double *, int *> pnPar;
  
  Root=treeP->getRootNode();
  MaxNivel=0;
  for(int k=0;k<Root->getNumberOfSons();k++){      MaxNivel+= getNivel(Root->getSon(k));   }

  dmax =MaxNivel; 
  //cout << "Dmax = " << dmax << endl;
   
  BestMovSPRPar.first=-1;  BestMovSPRPar.second=-1;
   
  for(Iteracion=0; Iteracion<NumIteraciones;Iteracion++){
      
        if (Iteracion%(NumIteraciones/MaxNivel+1)==0) dmax--;
      
        if(dmax < 3) dmax=3;
        else if(dmax > MaxNivel) dmax=MaxNivel;

        do{
              b=true;
              do {
                  Nodo1 =  nodes[rand()%nodes.size()];
                  if(Nodo1->hasFather()){
                      if(Nodo1->getFather()->hasFather()) b=false;
                  }
              }while(b);

              d=rand()%dmax+1; //Distancia entre 1 y DMax
              u=up=rand()%d+2; //Subir desde 2 a D

              Nodo2=Nodo1;
              Node* prev;
              while(Nodo2->hasFather() && (u>0)) {
                 prev=Nodo2;
                 Nodo2=Nodo2->getFather();
                 u--;
              }

              down=d+2-up-u;

            while(Nodo2->getNumberOfSons()>1 && (down>0)) {
                  Nodo2 = Nodo2->getSon(rand()% Nodo2->getNumberOfSons());
                  if(Nodo1==Nodo2) {
                      Nodo2=Nodo2->getFather();
                  }else  down --;
            }
         }while(!SPRvalide (Nodo1,Nodo2));
         
         
         
         if(!isMov(MovSPRPar,Nodo1->getId() , Nodo2->getId())){
      
             IDs.first=Nodo1->getId();         IDs.second=Nodo2->getId();
             MovSPRPar.push_back(IDs);
             
            //cout << "SPR 1" << endl;
            pPar=SPR(Nodo1, Nodo2, NextNodeIDPar); //Sobrr TreeParsimonia
            pnPar = pPar.first;
            //cout << "SPR 2" << endl;

            Par->topologyChangeTested(*new TopologyChangeEvent());
            //cout << "topologyChangeTested 2" << endl;

            ParsimonyScore = Par->getScore();
            if( ParsimonyScore < MenorParsimonia){
                
                MenorParsimonia = ParsimonyScore;
                
                BestMovSPRPar.first= IDs.first;
                BestMovSPRPar.second= IDs.second;
                
            }
            
          //cout << "Mejor Parsimonia SPR " << ParsimonyScore << endl;
           double *b = pnPar.first;
           if(b[0]==1){
              //cout << "SPR R 1" << endl;
              SPR(Nodo1,pPar.second,b);
              //cout << "SPR R 2" << endl;
           }else{
               //cout << "SPrrever 1" << endl;
               SPRreverse(Nodo1,pPar.second,b,NextNodeIDPar);
              //cout << "SPrrever 2" << endl;
            }
          

           delete[] pnPar.first;       delete[] pnPar.second;
          //if(Iteracion%100==0)      cout << "Iteracion " << Iteracion << endl; //<< " DMax " << dmax << " de " << MaxNivel << endl;
        
       }
  }
  
  delete Par;
   
  if(BestMovSPRPar.first!=-1 and BestMovSPRPar.second!=-1){
      
        double NewLik = 0;
        int NextNodeIDMutada = tree->getNextId();
        SPR(tree->getNode(BestMovSPRPar.first),tree->getNode(BestMovSPRPar.second), NextNodeIDMutada);
        
        NewLik =  OptimizarRamas(tree, Pt, problem_, NumIterOptRamas, TolerenciaOptRamas);
        
       //comprobar que pasandole las longi otimizadas queda mismo scroe del optimizas
       /*problem_->evaluate(solution);
       if( abs(solution->getObjective(0) - MenorParsimonia) > 2 or abs(solution->getObjective(1) -NewLik)>0.001  ){
                cout << "Error No da el mismo Parmisonia que TreeMutada que treeParsimonia " << solution->getObjective(0) << " " << MenorParsimonia  << "  Lik= " << solution->getObjective(1) << " " << NewLik << endl;
                cout << "Diferencia MP " << abs(solution->getObjective(0) - MenorParsimonia) << " ML " << abs(solution->getObjective(1) - NewLik) << endl;
                exit(-1);
        }*/

        solution->setObjective(0,MenorParsimonia);
        solution->setObjective(1,NewLik);
        
  }else{
      cout << "Ya No hay Ningun SPR BUENO " << endl;
  }
  
     /*nodes = tree->getNodes();
     double gamma; double distance;
     for(unsigned int i = 0; i < nodes.size(); i++){
       if (PseudoRandom::randDouble() <= 0.5) {
            if (nodes[i]->hasDistanceToFather()){
                     distance = nodes[i]->getDistanceToFather();
                     gamma =  gsl_ran_gamma (random_gsl, randomgsl_alpha, (1.0/randomgsl_alpha) );
                     if (distance * gamma != 0)	 nodes[i]->setDistanceToFather(distance * gamma);
             }
         }
     }*/
  
 cout << "Parsimonia F " <<  solution->getObjective(0) << "  Likelihood F " << solution->getObjective(1)  << endl;
 cout <<"============================================================" << endl;
}
    

//void PhylogeneticMutation::PPNOptimiz(Solution * solution){
//    cout <<"============================================================" << endl;
//    cout << "Scores Inicial: " << solution->getObjective(0) << " Lik: " << solution->getObjective(1) << endl;
//
//    //Optimized Tree 
//    PhyloTree * Pt = (PhyloTree*) solution->getDecisionVariables()[0];
//    Phylogeny * problem_ = (Phylogeny *) solution->getProblem();
//    TreeTemplate<Node> * tree = Pt->getTree();
//
//   
//     
//    vector< pair<int , int > > MovSPRPar;
//    vector< pair<int , int > > BestMovSPRPar;
//    vector<int> BestPar;
//    pair<int , int > IDs;
//    
//    vector<int>::iterator it;
//    vector< pair<int , int > >::iterator it2;
//    
//
//    //DRTreeParsimony usado para denotar los posibles buenos moviemitos basads en Parsimonia
//    DRTreeParsimonyScore * Par =	new DRTreeParsimonyScore(*tree, *problem_->getSites() ,false,true);
//    TreeTemplate<Node> * treeP = Par->getTreeP_();
//    vector<Node*> nodes = treeP->getNodes();
//    int NextNodeIDPar = treeP->getNextId();
//
//  
//    double ParsimonyScore;
//    int ParsimoniaOriginal = Par->getScore();
//     
//    Node * Root;
//    Node* Nodo1;
//    Node* Nodo2;
//
//  int MaxNivel, dmax,d,up,down,u, Iteracion;
//  bool b;
//  
//  pair< pair<double *, int *>, Node *> pPar;
//  pair<double *, int *> pnPar;
//  
//  Root=treeP->getRootNode();
//  MaxNivel=0;
//  for(int k=0;k<Root->getNumberOfSons();k++){      MaxNivel+= getNivel(Root->getSon(k));   }
//
//  dmax =MaxNivel; 
//  
//  for(Iteracion=0; Iteracion<NumIteraciones;Iteracion++){
//      
//        if (Iteracion%(NumIteraciones/MaxNivel+1)==0) dmax--;
//      
//        if(dmax < 3) dmax=3;
//        else if(dmax > MaxNivel) dmax=MaxNivel;
//
//        do{
//              b=true;
//              do {
//                  Nodo1 =  nodes[rand()%nodes.size()];
//                  if(Nodo1->hasFather()){
//                      if(Nodo1->getFather()->hasFather()) b=false;
//                  }
//              }while(b);
//
//              d=rand()%dmax+1; //Distancia entre 1 y DMax
//              u=up=rand()%d+2; //Subir desde 2 a D
//
//              Nodo2=Nodo1;
//              Node* prev;
//              while(Nodo2->hasFather() && (u>0)) {
//                 prev=Nodo2;
//                 Nodo2=Nodo2->getFather();
//                 u--;
//              }
//
//              down=d+2-up-u;
//
//            while(Nodo2->getNumberOfSons()>1 && (down>0)) {
//                  Nodo2 = Nodo2->getSon(rand()% Nodo2->getNumberOfSons());
//                  if(Nodo1==Nodo2) {
//                      Nodo2=Nodo2->getFather();
//                  }else  down --;
//            }
//         }while(!SPRvalide (Nodo1,Nodo2));
//         
//         
//         
//         if(!isMov(MovSPRPar,Nodo1->getId() , Nodo2->getId())){
//      
//             IDs.first=Nodo1->getId();         IDs.second=Nodo2->getId();
//             MovSPRPar.push_back(IDs);
//             
//            //cout << "SPR 1" << endl;
//            pPar=SPR(Nodo1, Nodo2, NextNodeIDPar); //Sobrr TreeParsimonia
//            pnPar = pPar.first;
//            //cout << "SPR 2" << endl;
//
//            Par->topologyChangeTested(*new TopologyChangeEvent());
//            //cout << "topologyChangeTested 2" << endl;
//
//            ParsimonyScore = Par->getScore();
//            if( ParsimonyScore < ParsimoniaOriginal){
//
//                if(!BestMovSPRPar.empty()){
//                        it2=BestMovSPRPar.begin();
//                        for (it=BestPar.begin()  ; it<BestPar.end(); it++){
//                            if(ParsimonyScore<*it){
//                                    BestPar.insert(it,ParsimonyScore);
//                                    BestMovSPRPar.insert(it2,IDs);
//                                    it=BestPar.end();
//                            }
//                            it2++; 
//                        }
//                        if(BestPar.size()>10) { BestPar.pop_back(); BestMovSPRPar.pop_back();} 
//                
//                }else{
//                         BestMovSPRPar.push_back(IDs);   BestPar.push_back(ParsimonyScore);
//                }
//            }
//            
//          //cout << "Mejor Parsimonia SPR " << ParsimonyScore << endl;
//           double *b = pnPar.first;
//           if(b[0]==1){
//              //cout << "SPR R 1" << endl;
//              SPR(Nodo1,pPar.second,b);
//              //cout << "SPR R 2" << endl;
//           }else{
//               //cout << "SPrrever 1" << endl;
//               SPRreverse(Nodo1,pPar.second,b,NextNodeIDPar);
//              //cout << "SPrrever 2" << endl;
//            }
//          
//
//           delete[] pnPar.first;       delete[] pnPar.second;
//          //if(Iteracion%100==0)      cout << "Iteracion " << Iteracion << endl; //<< " DMax " << dmax << " de " << MaxNivel << endl;
//        
//       }
//  }
//  
//  delete Par;
//   
//  //Temporal Tree 
//  Solution *SolMutada = new Solution(solution);
//  PhyloTree * PtM = (PhyloTree*) SolMutada->getDecisionVariables()[0];
//  TreeTemplate<Node> * treeM = PtM->getTree();
//
//  //Initial Tree 
//  Solution *SolIni = new Solution(solution);
//  PhyloTree * PtIni = (PhyloTree*) SolIni->getDecisionVariables()[0];
//  TreeTemplate<Node> * treeIni = PtIni->getTree();
//    
//  double NewLik;
//  int NextNodeIDMutada = treeM->getNextId();
//
//  
//  for(int i=BestMovSPRPar.size()-1;i>=0;i--){
//      
//      cout << "Best Pars " << i << " " << BestPar[i] << endl;
//      IDs = BestMovSPRPar[i];
//      SPR(treeM->getNode(IDs.first),treeM->getNode(IDs.second), NextNodeIDMutada);
//      
//      problem_->evaluate(SolMutada);
//      //if(SolMutada->getObjective(0) != BestPar[i]){
//        //  cout << "Error el SPR " << i << " No da el mismo Parmisnio que TreeMutada que treeParsimonia " << SolMutada->getObjective(0) << " " << BestPar[i] << endl;
//          //exit(-1);
//      //}
//              
//      //NewLik = OptimizarRamas(treeM, PtM, problem_, 2, 0.1);
//      //SolMutada->setObjective(0,BestPar[i]);            SolMutada->setObjective(1,NewLik);
//      cout << "Solucion Mutada Score SPR " << SolMutada->getObjective(0) << " Lik: " << SolMutada->getObjective(1) <<  endl;
//      
//      if(comparator->compare(solution, SolMutada)==1){
//           
//           Pt->setTree(new TreeTemplate<Node>(*treeM));
//           solution->setObjective(0,SolMutada->getObjective(0));
//           solution->setObjective(1,SolMutada->getObjective(1));
//
//           cout << "Mejor Solucion MO Mutada SPR: " << solution->getObjective(0) << " Lik: " << solution->getObjective(1) << endl;
//      
//      }
//
//      PtM->setTree(new TreeTemplate<Node>(*treeIni));
//      treeM = PtM->getTree();
//      NextNodeIDMutada = treeM->getNextId();
//      SolMutada->setObjective(0,SolIni->getObjective(0));
//      SolMutada->setObjective(1,SolIni->getObjective(1));
//  }
//  
//  
//   
//   delete SolMutada;
//   delete SolIni;
//
//  TreeTemplate<Node> * treeS = Pt->getTree();
//  NewLik = OptimizarRamas(treeS, Pt, problem_, 2, 0.1);
//  solution->setObjective(1,NewLik);
// 
// cout << "Scores Final: " << solution->getObjective(0) << " Lik: " << solution->getObjective(1) << endl;
// cout <<"============================================================" << endl;
//}


int  PhylogeneticMutation::SALS(Solution * solution){
    cout <<"============================================================" << endl;
    cout << "Scores Inicial: " << solution->getObjective(0) << " Lik: " << solution->getObjective(1) << endl;

    PhyloTree * Pt = (PhyloTree*) solution->getDecisionVariables()[0];
    Phylogeny * problem_ = (Phylogeny *) solution->getProblem();
    TreeTemplate<Node> * treeO = Pt->getTree();
    
    Solution *SolMutada = new Solution(solution);
    PhyloTree * PtM = (PhyloTree*) SolMutada->getDecisionVariables()[0];
    TreeTemplate<Node> * treeM = PtM->getTree();
    

    DRTreeParsimonyScore * Par =	new DRTreeParsimonyScore(*treeM, *problem_->getSites() ,false,true);
    TreeTemplate<Node> * treeP = Par->getTreeP_();
    vector<Node*> nodes = treeP->getNodes();
    
    Node* node;
    Node* nodeM;
    
    pair< pair<Node*, Node*>, pair <int , int> > p;
    pair< pair<Node*, Node*>, pair <int , int> > pM;
    double BestPar = Par->getScore();
    double NewLik;
      
    bool NNIMoves=false;
    for(int i=0;i<nodes.size();i++){
        node = nodes[i];
        if(NNIValidate(node)){
            p=NNI(node);
            Par->topologyChangeTested(*new TopologyChangeEvent());
            if(Par->getScore() < BestPar){
                NNIMoves=true;
                BestPar = Par->getScore();
                cout << "Nuevo Score Par " << Par->getScore() << endl;
                
                nodeM = treeM->getNode(node->getId());
                pM=NNI(nodeM, p.second);
                
                NewLik = OptimizarRamas(treeM, PtM, problem_, 2, 0.1);
                //problem_->evaluate(SolMutada);
                SolMutada->setObjective(0,Par->getScore());
                SolMutada->setObjective(1,NewLik); 
                 
                cout << "Solucion Mutada Score NNI " << SolMutada->getObjective(0) << " Lik: " << SolMutada->getObjective(1) <<  endl;
       
                if(comparator->compare(solution, SolMutada)==1){
                  cout << "Mejor Solucion MO Mutada NNI "  << endl; //<< SMutada->getObjective(0) << " Lik: " << SMutada->getObjective(1) << endl;

                  Pt->setTree(new TreeTemplate<Node>(*treeM));
                  solution->setObjective(0,SolMutada->getObjective(0));
                  solution->setObjective(1,SolMutada->getObjective(1));
                  
                   cout << "Scores NNI Final: " << solution->getObjective(0) << " Lik: " << solution->getObjective(1) << endl;
                   
                  delete Par;  delete SolMutada;
                  return 0;
                  
                   
                   
                }else{
                    //cout << "Reverse NNI " << endl;
                    
                    //NNIReverse(pM.first.first, pM.first.second);
                 
                    PtM->setTree(new TreeTemplate<Node>(*treeO));
                    treeM = PtM->getTree();
                    
                    problem_->evaluate(SolMutada);
                    cout << "SolutionMutada reverse: " << SolMutada->getObjective(0) << " Lik: " << SolMutada->getObjective(1) << endl;
                  
                    //cout << "Ya Tree Copiado " << endl;
                    //delete Par;
                    //Par = new DRTreeParsimonyScore(*treeM, *problem_->getSites() ,false,true);
                    //treeP = Par->getTreeP_();
                    //nodes = treeP->getNodes();
                    
                    //cout << "Ya nodes Copiado " << endl;
                    
                    //SolMutada->setObjective(0,solution->getObjective(0));
                    //SolMutada->setObjective(1,solution->getObjective(1));
                    //cout << "Ya Tree Copiado " << endl;
                }
                
                
                
            }
            NNIReverse(p.first.first, p.first.second);
        }
    }


  double ParsimonyScore;
  double MenorParsimonia = solution->getObjective(0);
     
  Node * Root;
  Node* Nodo1;
  Node* Nodo2;

  int MaxNivel, dmax,d,up,down,u, Iteracion;
  bool b;
  
  pair< pair<double *, int *>, Node *> pPar;
  pair<double *, int *> pnPar;

  pair< pair<double *, int *>, Node *> pTreeMutada;
  pair<double *, int *> pnTreeMutada;

  
  Root=treeP->getRootNode();
  MaxNivel=0;
  for(int k=0;k<Root->getNumberOfSons();k++){      MaxNivel+= getNivel(Root->getSon(k));   }

  dmax =MaxNivel; 
  
  int NextNodeIDPar = treeP->getNextId();
  int NextNodeIDMutada = treeM->getNextId();
  
  
  for(Iteracion=0; Iteracion<NumIteraciones;Iteracion++){
      
        if (Iteracion%(NumIteraciones/MaxNivel+1)==0) dmax--;
      
        if(dmax < 3) dmax=3;
        else if(dmax > MaxNivel) dmax=MaxNivel;

        do{
              b=true;
              do {
                  Nodo1 =  nodes[rand()%nodes.size()];
                  if(Nodo1->hasFather()){
                      if(Nodo1->getFather()->hasFather()) b=false;
                  }
              }while(b);

              d=rand()%dmax+1; //Distancia entre 1 y DMax
              u=up=rand()%d+2; //Subir desde 2 a D

              Nodo2=Nodo1;
              Node* prev;
              while(Nodo2->hasFather() && (u>0)) {
                 prev=Nodo2;
                 Nodo2=Nodo2->getFather();
                 u--;
              }

              down=d+2-up-u;

            while(Nodo2->getNumberOfSons()>1 && (down>0)) {
                  Nodo2 = Nodo2->getSon(rand()% Nodo2->getNumberOfSons());
                  if(Nodo1==Nodo2) {
                      Nodo2=Nodo2->getFather();
                  }else  down --;
            }
         }while(!SPRvalide (Nodo1,Nodo2));
      
         //cout << "SPR 1" << endl;
         pPar=SPR(Nodo1, Nodo2, NextNodeIDPar); //Sobrr TreeParsimonia
         pnPar = pPar.first;
         //cout << "SPR 2" << endl;

         Par->topologyChangeTested(*new TopologyChangeEvent());
         //cout << "topologyChangeTested 2" << endl;
         
         ParsimonyScore = Par->getScore();
         if( ParsimonyScore < MenorParsimonia){
             
             MenorParsimonia = ParsimonyScore;
             //cout << "Mejor Parsimonia SPR " << ParsimonyScore << endl;
             
             pTreeMutada=SPR(treeM->getNode(Nodo1->getId()),treeM->getNode(Nodo2->getId()), NextNodeIDMutada);
             pnTreeMutada = pTreeMutada.first;
             
             delete[] pnTreeMutada.first;   delete[] pnTreeMutada.second;
             
              NewLik = OptimizarRamas(treeM, PtM, problem_, 2, 0.1);
             
              SolMutada->setObjective(0,ParsimonyScore);            SolMutada->setObjective(1,NewLik); 
              cout << "Solucion Mutada Score SPR " << SolMutada->getObjective(0) << " Lik: " << SolMutada->getObjective(1) <<  endl;
       
              if(comparator->compare(solution, SolMutada)==1){
                  cout << "Mejor Solucion MO Mutada SPR "  << endl; //<< SMutada->getObjective(0) << " Lik: " << SMutada->getObjective(1) << endl;

                  Pt->setTree(new TreeTemplate<Node>(*treeM));
                  solution->setObjective(0,SolMutada->getObjective(0));
                  solution->setObjective(1,SolMutada->getObjective(1));
                  
                   cout << "Scores SPR Final: " << solution->getObjective(0) << " Lik: " << solution->getObjective(1) << endl;

                  delete Par;  delete SolMutada;
                  return 0;
                  
                }else{
                  
                    PtM->setTree(new TreeTemplate<Node>(*treeO));
                    treeM = PtM->getTree();
                    NextNodeIDMutada = treeM->getNextId();
                    SolMutada->setObjective(0,solution->getObjective(0));
                    SolMutada->setObjective(1,solution->getObjective(1));
                }
             
            //delete[] pnTreeMutada.second;

         }else{
              double *b = pnPar.first;
              if(b[0]==1){
                  //cout << "SPR R 1" << endl;
                  SPR(Nodo1,pPar.second,b);
                  //cout << "SPR R 2" << endl;
              }else{
                  //cout << "SPrrever 1" << endl;
                  SPRreverse(Nodo1,pPar.second,b,NextNodeIDPar);
                  //cout << "SPrrever 2" << endl;
              }
         }
         
        delete[] pnPar.first;       delete[] pnPar.second;
          //if(Iteracion%100==0)      cout << "Iteracion " << Iteracion << endl; //<< " DMax " << dmax << " de " << MaxNivel << endl;
        
  }
  
 
 delete Par;
 delete SolMutada;
 
 vector<Node*> nodos = treeO->getNodes();
 Node * NodoSel;
 do{
     NodoSel=  nodos[rand()%nodos.size()];
 }while(!NNIValidate(NodoSel));
 
 //cout << "Aplica NNI 1" << endl;
 NNI(NodoSel);
 //cout << "Aplica NNI 2" << endl;
 
 problem_->evaluate(solution);
 cout << "Scores Solo NNI Simple: " << solution->getObjective(0) << " Lik: " << solution->getObjective(1) << endl;
 cout <<"============================================================" << endl;
}

pair< pair<Node*, Node*>  , pair<int, int> > PhylogeneticMutation::NNI(Node * NodoSel){
    
    pair<Node*, Node*> pnodos;
    pair<int, int> pos;
    
    pair< pair<Node*, Node*> ,pair<int, int> > p;
    
    Node * Nodo1;
    Node * Nodo2;
    int Pos1, Pos2;

    Pos1 = PseudoRandom::randInt(0, NodoSel->getSon(0)->getNumberOfSons()-1);
    Pos2 = PseudoRandom::randInt(0, NodoSel->getSon(1)->getNumberOfSons()-1);

    Nodo1=  NodoSel->getSon(0)->getSon(Pos1);
    Nodo2=  NodoSel->getSon(1)->getSon(Pos2);

    NodoSel->getSon(0)->setSon(Pos1,Nodo2);
    NodoSel->getSon(1)->setSon(Pos2,Nodo1);

    pnodos.first=Nodo1; pnodos.second=Nodo2;
    pos.first=Pos1; pos.second=Pos2;
    
    
    p.first=pnodos; p.second=pos;
    return p;
}

pair< pair<Node*, Node*>  , pair<int, int> > PhylogeneticMutation::NNI(Node * NodoSel, pair<int, int> pos){
    
    pair<Node*, Node*> pnodos;
    pair <pair<Node*, Node*>  , pair<int, int> > p;
    
    Node * Nodo1;
    Node * Nodo2;
    int Pos1, Pos2;

    Pos1 = pos.first;
    Pos2 = pos.second;


    Nodo1=  NodoSel->getSon(0)->getSon(Pos1);
    Nodo2=  NodoSel->getSon(1)->getSon(Pos2);

    NodoSel->getSon(0)->setSon(Pos1,Nodo2);
    NodoSel->getSon(1)->setSon(Pos2,Nodo1);

    pnodos.first=Nodo1; pnodos.second=Nodo2;
    
    
    p.first=pnodos; p.second=pos;
    return p;
}



void PhylogeneticMutation::NNIReverse(Node * NodoA, Node * NodoB){
    
    Node * PadreA;
    Node * PadreB;
    int Pos1, Pos2;
    
    PadreB = NodoB->getFather();      PadreA = NodoA->getFather();
    Pos1=PadreB->getSonPosition(NodoB);    Pos2=PadreA->getSonPosition(NodoA);
    PadreB->setSon(Pos1, NodoA);    PadreA->setSon(Pos2 , NodoB);


}

void PhylogeneticMutation::PPN_LS2(Solution * solution){
  cout <<"============================================================" << endl;
  cout << "Scores Inicio: " << solution->getObjective(0) << " Lik: " << solution->getObjective(1) << endl;
  
  Solution *SMutada = new Solution(solution); 
    
  PhyloTree * Pt = (PhyloTree*) SMutada->getDecisionVariables()[0];
  PhyloTree * Pt2 = ((PhyloTree*) solution->getDecisionVariables()[0]);
  TreeTemplate<Node> * tree = Pt->getTree();
  Phylogeny * problem_ = (Phylogeny *) SMutada->getProblem();

  Node * Root;
  Node* Nodo1;
  Node* Nodo2;

  
  int MaxNivel, dmax,d,up,down,u, Iteracion, idN1;
  bool b;
  
  pair< pair<double *, int *>, Node *> p;
  pair<double *, int *> pn;

  Root=tree->getRootNode();
  MaxNivel=0;
  for(int k=0;k<Root->getNumberOfSons();k++){      MaxNivel+= getNivel(Root->getSon(k));   }

  dmax =MaxNivel; 
  
  vector<int> nodosIDs = tree->getNodesId();
  int NextNodeID = tree->getNextId();
  int bsr;
  
  DRTreeParsimonyScore * Par =	new DRTreeParsimonyScore(*tree, *problem_->getSites() ,false,true);
  TreeTemplate<Node> * treeP = Par->getTreeP_();
  
  //NNIHomogeneousTreeLikelihood * Lik= new NNIHomogeneousTreeLikelihood(*tree, *problem_->getSites2(), problem_->model, problem_->rateDist, true, false);
  //Lik->initialize();
  //TreeTemplate<Node> * treeL = Lik->getTreeP_();
  
         
  for(Iteracion=0; Iteracion<NumIteraciones;Iteracion++){
      
        if (Iteracion%(NumIteraciones/MaxNivel+1)==0) dmax--;
      
        if(dmax < 3) dmax=3;
        else if(dmax > MaxNivel) dmax=MaxNivel;

        do{
              b=true;
              do {
                  do  idN1 =  rand()%nodosIDs.size();
                  while(!tree->hasNode(nodosIDs[idN1]));
                  
                  Nodo1 =  tree->getNode( nodosIDs[idN1]);
                  
                  if(Nodo1->hasFather()){
                      if(Nodo1->getFather()->hasFather()) b=false;
                  }
              }while(b);

              //cout << "Nodo1 " << Nodo1->getId()<< endl;

              d=rand()%dmax+1; //Distancia entre 1 y DMax

              u=up=rand()%d+2; //Subir desde 2 a D

             //cout << "dmax " << dmax << " d " << d << " u " << u;

              Nodo2=Nodo1;
              Node* prev;
              while(Nodo2->hasFather() && (u>0)) {
                 prev=Nodo2;
                 Nodo2=Nodo2->getFather();
                 u--;
              }

              down=d+2-up-u;

             //cout << " down " << down << endl;

            /*if (down>0) {
              if (prev->getP()==Rnoeud->getG()) Rnoeud=Rnoeud->getD();
              else Rnoeud=Rnoeud->getG();
              down--;
            }*/

            //cout << "Bajando " << endl;
            while(Nodo2->getNumberOfSons()>1 && (down>0)) {
                  Nodo2 = Nodo2->getSon(rand()% Nodo2->getNumberOfSons());
                  if(Nodo1==Nodo2) {
                      //cout << "N1 es igual N2 getNumberOfSons= " << Nodo2->getNumberOfSons() << endl;
                      Nodo2=Nodo2->getFather();
                  }else  down --;
                  //cout << N2->getId() << " - ";
            }

            //cout << endl << "Nodo2 " << Nodo2->getId()<< endl;

         }while(!SPRvalide (Nodo1,Nodo2));
      
         /*Newick * N2 = new Newick();
         N2->write(*treeL,"TL.txt");
         N2->write(*tree,"T.txt");
         delete N2;

         ParameterList PBL1 = Lik->getBranchLengthsParameters();*/
         
         //SPR(treeL->getNode(Nodo1->getId()),treeL->getNode(Nodo2->getId()), 1, Lik);
         
         //problem_->evaluate(SMutada, Par);
         //cout << " Lik " << SMutada->getObjective(1);
          
         //cout << "SPR 1" << endl;
         p=SPR(Nodo1, Nodo2, NextNodeID);
         //cout << "SPR 2" << endl;
         
         pn = p.first;

         SPR(treeP->getNode(Nodo1->getId()),treeP->getNode(Nodo2->getId()), bsr);
         //cout << "SPR 3" << endl;
         
         
         /*ParameterList PBL2 = Lik->getBranchLengthsParameters();
         for(int k=0;k< PBL1.size();k++){
             if (PBL1[k].getValue() != PBL2[k].getValue() )
                cout << "BL " << PBL1[k].getName() << " " << PBL1[k].getValue()  << " " << PBL2[k].getValue()   << endl;
         }
          */
         
         //cout << "d " << d << " dmax " << dmax << " MaxNivel " << MaxNivel << " d/MaxNivel " << (double)d/(double)MaxNivel << endl;
         
         //ModificarRamasDistGamma(SMutada);
         
         /*if( ((double)d/(double)MaxNivel)>0.5) {
             if(OptRamas || OptModeloyTasaDist)  OptimizarRamasyParamModeloSust(solution);
         }*/
         
         //cout << "SPR Done " << endl;

         //cout << "Hermano ID " << ((Node*)p.second)->getId() << endl;
         
         
         //tree->resetNodesId(); //Uniion de otro subNodos se deben resetear ID

         
         /*N2 = new Newick();
         N2->write(*treeL,"TL1.txt");
         N2->write(*tree,"T1.txt");
         delete N2;*/
         
          //problem_->evaluate(SMutada);
          //problem_->evaluateConstraints(SMutada);
          
          //cout << "topologyChangeTested 1" << endl;
          Par->topologyChangeTested(*new TopologyChangeEvent());
          //cout << "topologyChangeTested 2" << endl;
          //Lik->topologyChangeTested(*new TopologyChangeEvent());
          
         /*Newick * N = new Newick();
         N->write(*treeP,"TL2.txt");
         N->write(*tree,"T2.txt");
         delete N;

          if(!TreeTemplateTools::haveSameOrderedTopology(*treeP->getRootNode(), *tree->getRootNode()))
             cout << "Topolagias  Par y Tree NO IGUALES " << endl;
         
          if(Par->getScore() != SMutada->getObjective(0))
              cout << "Parsimonia Diferentes " << Par->getScore()  << " - " << SMutada->getObjective(0) << endl;
          
          if(-Lik->getValue() != SMutada->getObjective(1))
              cout << "Likelihood Diferentes " << -Lik->getValue() << " - " << SMutada->getObjective(1) << endl;
          */
          
          //cout << "Evaluate 1" << endl;
          problem_->evaluate(SMutada, Par);
          //cout << "Evaluate 2" << endl;
          //cout << " After " << SMutada->getObjective(1);
          
          //if(comparator->compare(solution, SMutada)==1){
          
          if(SMutada->getObjective(0) < solution->getObjective(0)){
                
              //cout << "SMutada mejor Parsimonia " << SMutada->getObjective(0) << endl;
              
              /*int  *IDs = pn.second;
              vector<string> Ramas;
              vector <Node *> nodos = tree->getNodes();
              for(int k=0;k<3;k++)  Ramas.push_back(getBrachNameProperty(IDs[k],nodos));
              
              double NewLik = OptimizarRamasAfterSRP(tree, Ramas, problem_, 10000 , 0.00001);
              //cout << "Optimizacion 3 Ramas " << NewLik << endl;
              if (NewLik!=0){
                    //cout << "Reset Tree 1" << endl;
                    Pt->setTree(tree);
                    nodosIDs = tree->getNodesId();
                    delete Par;
                    Par = new DRTreeParsimonyScore(*tree, *problem_->getSites() ,false,true);
                    treeP = Par->getTreeP_();
                    
                    //cout << "Reset Tree 2" << endl;
              }*/
  
              //problem_->evaluate(SMutada);
             
            
              
                 //ModificarRamasDistGamma(SMutada);
                
               //if(comparator->compare(solution, SMutada)==1){
                   //cout << "SMutada mejor AmbosObjs " << endl;

                   Pt2->setTree(new TreeTemplate<Node>(*tree));
                   
                   solution->setObjective(0,SMutada->getObjective(0));
                   //solution->setObjective(1,SMutada->getObjective(1));
               //}
              
                  // cout << "Set Solution " << endl;

          }else{
              double *b = pn.first;
              if(b[0]==1){
                  //cout << "SPR R 1" << endl;
                  SPR(Nodo1,p.second,b);
                  SPR(treeP->getNode(Nodo1->getId()),treeP->getNode(p.second->getId()),b);
                  //SPR(treeL->getNode(Nodo1->getId()),treeL->getNode(p.second->getId()),1,Lik);
                   
                  //cout << "SPR R 2" << endl;
              }else{
                  //cout << "SPrrever 1" << endl;
                  SPRreverse(Nodo1,p.second,b,NextNodeID);
                  SPRreverse(treeP->getNode(Nodo1->getId()),treeP->getNode(p.second->getId()),b,bsr);
                  //SPRreverse(treeL->getNode(Nodo1->getId()),treeL->getNode(p.second->getId()));
                  //cout << "SPrrever 2" << endl;
              }
              
              //problem_->evaluate(SMutada, Par);
              //cout << " 2 " << SMutada->getObjective(1) << endl;
              
              SMutada->setObjective(0,solution->getObjective(0));
              SMutada->setObjective(1,solution->getObjective(1));
              
              //cout << " Cambian obj 2 " << endl;

          }
          delete[] pn.first;       delete[] pn.second;
          
          //if(Iteracion%100==0)      cout << "Iteracion " << Iteracion << endl; //<< " DMax " << dmax << " de " << MaxNivel << endl;
  }
  
  delete Par;
  delete SMutada;
  
  //cout << "Delete ambas " << endl;
  
  //if(OptRamas || OptModeloyTasaDist)  OptimizarRamasyParamModeloSust(solution);
  problem_->evaluate(solution);
  cout << "Scores Final: " << solution->getObjective(0) << " Lik: " << solution->getObjective(1) << endl;
  cout <<"============================================================" << endl;
}

void PhylogeneticMutation::PPN_LSPar(Solution * solution){
  cout <<"============================================================" << endl;
  cout << "Scores Inicio: " << solution->getObjective(0) << " Lik: " << solution->getObjective(1) << endl;
  
  Solution *SMutada = new Solution(solution); 
  PhyloTree * Pt = (PhyloTree*) SMutada->getDecisionVariables()[0];
  PhyloTree * Pt2 = ((PhyloTree*) solution->getDecisionVariables()[0]);
  
  TreeTemplate<Node> * tree = Pt->getTree();
  Phylogeny * problem_ = (Phylogeny *) SMutada->getProblem();

  Node * Root;
  Node* Nodo1;
  Node* Nodo2;

  
  int MaxNivel, dmax,d,up,down,u, Iteracion, idN1;
  bool b;
  
  pair< pair<double *, int *>, Node *> p;
  pair<double *, int *> pn;
  
  //pair< pair<double *, int *>, Node *> p2;
  //pair<double *, int *> pn2;

  DRTreeParsimonyScore * Par =	new DRTreeParsimonyScore(*tree, *problem_->getSites() ,false,true);
  TreeTemplate<Node> * treeP = Par->getTreeP_();
  
  vector<int> nodosIDs = treeP->getNodesId();
  int NextNodeID = treeP->getNextId();
  int bsr;
  
  Root=treeP->getRootNode();
  MaxNivel=0;
  for(int k=0;k<Root->getNumberOfSons();k++){      MaxNivel+= getNivel(Root->getSon(k));   }

  dmax =MaxNivel; 
  
  
  for(Iteracion=0; Iteracion<NumIteraciones;Iteracion++){
      
        if (Iteracion%(NumIteraciones/MaxNivel+1)==0) dmax--;
      
        if(dmax < 3) dmax=3;
        else if(dmax > MaxNivel) dmax=MaxNivel;

        do{
              b=true;
              do {
                  do  idN1 =  rand()%nodosIDs.size();
                  while(!treeP->hasNode(nodosIDs[idN1]));
                  
                  Nodo1 =  treeP->getNode( nodosIDs[idN1]);
                  
                  if(Nodo1->hasFather()){
                      if(Nodo1->getFather()->hasFather()) b=false;
                  }
              }while(b);

              //cout << "Nodo1 " << Nodo1->getId()<< endl;

              d=rand()%dmax+1; //Distancia entre 1 y DMax

              u=up=rand()%d+2; //Subir desde 2 a D

             //cout << "dmax " << dmax << " d " << d << " u " << u;

              Nodo2=Nodo1;
              Node* prev;
              while(Nodo2->hasFather() && (u>0)) {
                 prev=Nodo2;
                 Nodo2=Nodo2->getFather();
                 u--;
              }

              down=d+2-up-u;

             //cout << " down " << down << endl;

            /*if (down>0) {
              if (prev->getP()==Rnoeud->getG()) Rnoeud=Rnoeud->getD();
              else Rnoeud=Rnoeud->getG();
              down--;
            }*/

            //cout << "Bajando " << endl;
            while(Nodo2->getNumberOfSons()>1 && (down>0)) {
                  Nodo2 = Nodo2->getSon(rand()% Nodo2->getNumberOfSons());
                  if(Nodo1==Nodo2) {
                      //cout << "N1 es igual N2 getNumberOfSons= " << Nodo2->getNumberOfSons() << endl;
                      Nodo2=Nodo2->getFather();
                  }else  down --;
                  //cout << N2->getId() << " - ";
            }

            //cout << endl << "Nodo2 " << Nodo2->getId()<< endl;

         }while(!SPRvalide (Nodo1,Nodo2));
      
         //cout << "SPR 1" << endl;
         p=SPR(Nodo1, Nodo2, NextNodeID);
         pn = p.first;
         //cout << "SPR 3" << endl;
         
          //cout << "topologyChangeTested 1" << endl;
          Par->topologyChangeTested(*new TopologyChangeEvent());
          //cout << "topologyChangeTested 2" << endl;

          if( Par->getScore() < solution->getObjective(0)){
               cout << "SMutada mejor Parsimonia " << Par->getScore() << endl;
             
               //p2=SPR(tree->getNode(Nodo1->getId()),tree->getNode(Nodo2->getId()), NextNodeID );
                
               
              
               //if(comparator->compare(solution, SMutada)==1){
                   //cout << "SMutada mejor AmbosObjs " << endl;

                   Pt2->setTree(new TreeTemplate<Node>(*treeP));
                   
                   solution->setObjective(0,Par->getScore());
                   //solution->setObjective(1,SMutada->getObjective(1));
               //}
              
                  // cout << "Set Solution " << endl;

                   Iteracion=NumIteraciones;
                   
          }else{
              double *b = pn.first;
              if(b[0]==1){
                  //cout << "SPR R 1" << endl;
                  SPR(Nodo1,p.second,b);
                  //SPR(treeP->getNode(Nodo1->getId()),treeP->getNode(p.second->getId()),b);
                  //SPR(treeL->getNode(Nodo1->getId()),treeL->getNode(p.second->getId()),1,Lik);
                   
                  //cout << "SPR R 2" << endl;
              }else{
                  //cout << "SPrrever 1" << endl;
                  SPRreverse(Nodo1,p.second,b,NextNodeID);
                  //SPRreverse(treeP->getNode(Nodo1->getId()),treeP->getNode(p.second->getId()),b,bsr);
                  //SPRreverse(treeL->getNode(Nodo1->getId()),treeL->getNode(p.second->getId()));
                  //cout << "SPrrever 2" << endl;
              }
              
              //problem_->evaluate(SMutada, Par);
              //cout << " 2 " << SMutada->getObjective(1) << endl;
              
              SMutada->setObjective(0,solution->getObjective(0));
              //SMutada->setObjective(1,solution->getObjective(1));
              
              //cout << " Cambian obj 2 " << endl;

          }
          delete[] pn.first;       delete[] pn.second;
          
          //if(Iteracion%100==0)      cout << "Iteracion " << Iteracion << endl; //<< " DMax " << dmax << " de " << MaxNivel << endl;
  }
  
  delete Par;
  delete SMutada;
  
  //cout << "Delete ambas " << endl;
  
  //if(OptRamas || OptModeloyTasaDist)  OptimizarRamasyParamModeloSust(solution);
  //problem_->evaluate(solution);
  cout << "Scores Final: " << solution->getObjective(0) << " Lik: " << solution->getObjective(1) << endl;
  cout <<"============================================================" << endl;
}

void PhylogeneticMutation::PPN_LS3(Solution * solution){
  cout <<"============================================================" << endl;
  cout << "Scores Inicio: " << solution->getObjective(0) << " Lik: " << solution->getObjective(1) << endl;
  
  Solution *SMutada = new Solution(solution); 
    
  PhyloTree * Pt = (PhyloTree*) SMutada->getDecisionVariables()[0];
  PhyloTree * Pt2 = ((PhyloTree*) solution->getDecisionVariables()[0]);
  TreeTemplate<Node> * treeMutada = Pt->getTree();
  Phylogeny * problem_ = (Phylogeny *) SMutada->getProblem();

  DRTreeParsimonyScore * EvaluadorParsimonia;
          
  Node * Root;
  Node* Nodo1;
  Node* Nodo2;

  
  int MaxNivel, dmax,d,up,down,u, Iteracion, idN1;
  bool b;
  
  pair< pair<double *, int *>, Node *> p;
  pair<double *, int *> pn;

  Root=treeMutada->getRootNode();
  MaxNivel=0;
  for(int k=0;k<Root->getNumberOfSons();k++){      MaxNivel+= getNivel(Root->getSon(k));   }

  dmax =MaxNivel; 
  
  vector<int> nodosIDs = treeMutada->getNodesId();
  int NextNodeID = treeMutada->getNextId();
  int bsr;
  
  
  for(Iteracion=0; Iteracion<NumIteraciones;Iteracion++){
      
        if (Iteracion%(NumIteraciones/MaxNivel+1)==0) dmax--;
      
        if(dmax < 3) dmax=3;
        else if(dmax > MaxNivel) dmax=MaxNivel;

        do{
              b=true;
              do {
                  do  idN1 =  rand()%nodosIDs.size();
                  while(!treeMutada->hasNode(nodosIDs[idN1]));
                  
                  Nodo1 =  treeMutada->getNode( nodosIDs[idN1]);
                  
                  if(Nodo1->hasFather()){
                      if(Nodo1->getFather()->hasFather()) b=false;
                  }
              }while(b);

              //cout << "Nodo1 " << Nodo1->getId()<< endl;

              d=rand()%dmax+1; //Distancia entre 1 y DMax

              u=up=rand()%d+2; //Subir desde 2 a D

             //cout << "dmax " << dmax << " d " << d << " u " << u;

              Nodo2=Nodo1;
              Node* prev;
              while(Nodo2->hasFather() && (u>0)) {
                 prev=Nodo2;
                 Nodo2=Nodo2->getFather();
                 u--;
              }

              down=d+2-up-u;

             //cout << " down " << down << endl;

            /*if (down>0) {
              if (prev->getP()==Rnoeud->getG()) Rnoeud=Rnoeud->getD();
              else Rnoeud=Rnoeud->getG();
              down--;
            }*/

            //cout << "Bajando " << endl;
            while(Nodo2->getNumberOfSons()>1 && (down>0)) {
                  Nodo2 = Nodo2->getSon(rand()% Nodo2->getNumberOfSons());
                  if(Nodo1==Nodo2) {
                      //cout << "N1 es igual N2 getNumberOfSons= " << Nodo2->getNumberOfSons() << endl;
                      Nodo2=Nodo2->getFather();
                  }else  down --;
                  //cout << N2->getId() << " - ";
            }

            //cout << endl << "Nodo2 " << Nodo2->getId()<< endl;

         }while(!SPRvalide (Nodo1,Nodo2));
      
         //cout << "SPR 1" << endl;
         p=SPR(Nodo1, Nodo2, NextNodeID); //Sobrr TreeParsimonia
         pn = p.first;
         //cout << "SPR 2" << endl;

         
         EvaluadorParsimonia =	new DRTreeParsimonyScore(*treeMutada, *problem_->getSites() ,false,true);
         //cout << "topologyChangeTested 2" << endl;
         
         
         if(EvaluadorParsimonia->getScore()  < solution->getObjective(0)){
             
             cout << "Mejor Parsimonia SPR " << EvaluadorParsimonia->getScore() << endl;
             
             int  *IDs = pn.second;
             vector<string> Ramas;
             vector <Node *> nodos = treeMutada->getNodes();
             //Los BarnchNamesPropertys seran los mismos sobre el tree del RHomerLik a Optimizar
             for(int k=0;k<3;k++)  Ramas.push_back(getBrachNameProperty(IDs[k],nodos));

              double * BranchOptimizadas = OptimizarRamasAfterSRP(treeMutada, Pt, Ramas, problem_, 10000 , 0.00001);
              for(int k=0;k<3;k++) {
                  if(BranchOptimizadas[k]!=0){
                      treeMutada->getNode(IDs[k])->setDistanceToFather(BranchOptimizadas[k]);
                  }
              }
              delete[] BranchOptimizadas; 
                  
           
             problem_->evaluate(SMutada);
             
             cout << "Solucion Mutada Score " << SMutada->getObjective(0) << " Lik: " << SMutada->getObjective(1) <<  endl;
             
             if(comparator->compare(solution, SMutada)==1){
                   cout << "Mejor Solucion MO Mutada " <<  endl;

                   Pt2->setTree(new TreeTemplate<Node>(*treeMutada));
                   
                   solution->setObjective(0,SMutada->getObjective(0));
                   solution->setObjective(1,SMutada->getObjective(1));

             }else{
                 
                 double *b = pn.first;
                 if(b[0]==1){
                  //cout << "SPR R 1" << endl;
                  SPR(Nodo1,p.second,b);
                  //cout << "SPR R 2" << endl;
                }else{
                  //cout << "SPrrever 1" << endl;
                  SPRreverse(Nodo1,p.second,b,NextNodeID);
                  //cout << "SPrrever 2" << endl;
                }
                  
                SMutada->setObjective(0,solution->getObjective(0));
                SMutada->setObjective(1,solution->getObjective(1));
             }

         }else{
              double *b = pn.first;
              if(b[0]==1){
                  //cout << "SPR R 1" << endl;
                  SPR(Nodo1,p.second,b);
                  //cout << "SPR R 2" << endl;
              }else{
                  //cout << "SPrrever 1" << endl;
                  SPRreverse(Nodo1,p.second,b,NextNodeID);
                  //cout << "SPrrever 2" << endl;
              }
         }
         
         delete[] pn.first;       delete[] pn.second;
          //if(Iteracion%100==0)      cout << "Iteracion " << Iteracion << endl; //<< " DMax " << dmax << " de " << MaxNivel << endl;
        delete EvaluadorParsimonia;
  }
  
  
  delete SMutada;
  
  //cout << "Delete ambas " << endl;
  
 // if(OptRamas || OptModeloyTasaDist)  OptimizarRamasyParamModeloSust(solution);
  problem_->evaluate(solution);
  cout << "Scores Final: " << solution->getObjective(0) << " Lik: " << solution->getObjective(1) << endl;
  cout <<"============================================================" << endl;
}

/*Intenta mejorar parsimonia ALmacena las 5 mejores parsimonias, y a esasles aplica nwton todas las ramas*/
void PhylogeneticMutation::PPN_LS(Solution * solution){
  cout <<"============================================================" << endl;
  cout << "Scores Inicio: " << solution->getObjective(0) << " Lik: " << solution->getObjective(1) << endl;
  
  vector<double> v;
  vector<int*> vIDs;
  vector<TreeTemplate<Node>*> a;
  vector<double>::iterator it;
  vector<int*>::iterator it4;
  vector<TreeTemplate<Node>*>::iterator it2;  
  double ParsimonyScore;
  double MenorParsimonia = solution->getObjective(0);
     
  Phylogeny * problem_ = (Phylogeny *) solution->getProblem();
  PhyloTree * Pt2 = ((PhyloTree*) solution->getDecisionVariables()[0]);

  TreeTemplate<Node> * treeMutada = new TreeTemplate<Node>(*Pt2->getTree());
  
  DRTreeParsimonyScore * Par =	new DRTreeParsimonyScore(*Pt2->getTree(), *problem_->getSites() ,false,true);
  TreeTemplate<Node> * treeP = Par->getTreeP_();
  
  Node * Root;
  Node* Nodo1;
  Node* Nodo2;

  int MaxNivel, dmax,d,up,down,u, Iteracion, idN1;
  bool b;
  
  pair< pair<double *, int *>, Node *> pPar;
  pair<double *, int *> pnPar;

  pair< pair<double *, int *>, Node *> pTreeMutada;
  pair<double *, int *> pnTreeMutada;

  
  Root=treeP->getRootNode();
  MaxNivel=0;
  for(int k=0;k<Root->getNumberOfSons();k++){      MaxNivel+= getNivel(Root->getSon(k));   }

  dmax =MaxNivel; 
  
  vector<int> nodosIDs = treeP->getNodesId();
  int NextNodeID = treeP->getNextId();
  int bsr;
  
  
  for(Iteracion=0; Iteracion<NumIteraciones;Iteracion++){
      
        if (Iteracion%(NumIteraciones/MaxNivel+1)==0) dmax--;
      
        if(dmax < 3) dmax=3;
        else if(dmax > MaxNivel) dmax=MaxNivel;

        do{
              b=true;
              do {
                  do  idN1 =  rand()%nodosIDs.size();
                  while(!treeP->hasNode(nodosIDs[idN1]));
                  
                  Nodo1 =  treeP->getNode( nodosIDs[idN1]);
                  
                  if(Nodo1->hasFather()){
                      if(Nodo1->getFather()->hasFather()) b=false;
                  }
              }while(b);

              //cout << "Nodo1 " << Nodo1->getId()<< endl;

              d=rand()%dmax+1; //Distancia entre 1 y DMax

              u=up=rand()%d+2; //Subir desde 2 a D

             //cout << "dmax " << dmax << " d " << d << " u " << u;

              Nodo2=Nodo1;
              Node* prev;
              while(Nodo2->hasFather() && (u>0)) {
                 prev=Nodo2;
                 Nodo2=Nodo2->getFather();
                 u--;
              }

              down=d+2-up-u;

             //cout << " down " << down << endl;

            /*if (down>0) {
              if (prev->getP()==Rnoeud->getG()) Rnoeud=Rnoeud->getD();
              else Rnoeud=Rnoeud->getG();
              down--;
            }*/

            //cout << "Bajando " << endl;
            while(Nodo2->getNumberOfSons()>1 && (down>0)) {
                  Nodo2 = Nodo2->getSon(rand()% Nodo2->getNumberOfSons());
                  if(Nodo1==Nodo2) {
                      //cout << "N1 es igual N2 getNumberOfSons= " << Nodo2->getNumberOfSons() << endl;
                      Nodo2=Nodo2->getFather();
                  }else  down --;
                  //cout << N2->getId() << " - ";
            }

            //cout << endl << "Nodo2 " << Nodo2->getId()<< endl;

         }while(!SPRvalide (Nodo1,Nodo2));
      
         //cout << "SPR 1" << endl;
         pPar=SPR(Nodo1, Nodo2, bsr); //Sobrr TreeParsimonia
         pnPar = pPar.first;
         //cout << "SPR 2" << endl;

         Par->topologyChangeTested(*new TopologyChangeEvent());
         //cout << "topologyChangeTested 2" << endl;
         
         ParsimonyScore = Par->getScore();
         if( ParsimonyScore < MenorParsimonia){
             
             MenorParsimonia = ParsimonyScore;
             //cout << "Mejor Parsimonia SPR " << ParsimonyScore << endl;
             
             pTreeMutada=SPR(treeMutada->getNode(Nodo1->getId()),treeMutada->getNode(Nodo2->getId()), NextNodeID);
             pnTreeMutada = pTreeMutada.first;
             
             int  *IDs = pnTreeMutada.second;
                        
             if(!a.empty()){
                it2=a.begin();
                it4=vIDs.begin();
                for (it=v.begin()  ; it<v.end(); it++){
                        if(ParsimonyScore<*it){
                                v.insert(it,ParsimonyScore);
                                vIDs.insert(it4,IDs);
                                a.insert(it2,treeMutada->clone());
                                it=v.end();
                        }
                        it2++; it4++;
                }
                
                if(v.size()>10) { v.pop_back(); a.pop_back();  vIDs.pop_back(); } 
                
            }else{
                 v.push_back(ParsimonyScore); a.push_back(treeMutada->clone());
                 vIDs.push_back(IDs);
            }
             
          
             
             delete[] pnTreeMutada.first;       
            //delete[] pnTreeMutada.second;

         }else{
              double *b = pnPar.first;
              if(b[0]==1){
                  //cout << "SPR R 1" << endl;
                  SPR(Nodo1,pPar.second,b);
                  //cout << "SPR R 2" << endl;
              }else{
                  //cout << "SPrrever 1" << endl;
                  SPRreverse(Nodo1,pPar.second,b,bsr);
                  //cout << "SPrrever 2" << endl;
              }
         }
         
        delete[] pnPar.first;       delete[] pnPar.second;
          //if(Iteracion%100==0)      cout << "Iteracion " << Iteracion << endl; //<< " DMax " << dmax << " de " << MaxNivel << endl;
        
  }
  
  delete treeMutada;
  delete Par;
    
  
  if(!a.empty()){
        cout<< "Mejores Arboles Parsimonios " << endl;
        for (int i=0;i<v.size();i++)   cout << v[i] << " ";
        cout << endl;
  
        cout << "Optimizacion Ramas a los bestTreesParsimonios " << endl;
        Solution *SMutada = new Solution(solution); 
        PhyloTree * Pt = (PhyloTree*) SMutada->getDecisionVariables()[0];
        //treeMutada = Pt->getTree();
        
        double NewLik;
        /*int  *IDs;
        vector<string> Ramas;
        vector <Node *> nodos;
        double * BranchOptimizadas;*/
        for (int i=0;i<a.size();i++){
            
         NewLik = OptimizarRamas(a[i], Pt, problem_, 2, 0.1);
            
         treeMutada = a[i];
         /*IDs = vIDs[i];
         nodos = treeMutada->getNodes();
         //Los BarnchNamesPropertys seran los mismos sobre el tree del RHomerLik a Optimizar
         for(int k=0;k<3;k++)  Ramas.push_back(getBrachNameProperty(IDs[k],nodos));
         BranchOptimizadas = OptimizarRamasAfterSRP(treeMutada, Pt, Ramas, problem_, 10000 , 0.00001);
         for(int k=1;k<4;k++) {
                if(BranchOptimizadas[k]!=0){
                        treeMutada->getNode(IDs[k-1])->setDistanceToFather(BranchOptimizadas[k]);
                }
         }
         Ramas.clear(); nodos.clear();*/
         
         Pt->setTree(treeMutada);
         //problem_->evaluate(SMutada);
         SMutada->setObjective(0,v[i]);
         //SMutada->setObjective(1,BranchOptimizadas[0]); 
         SMutada->setObjective(1,NewLik); 
             
         //delete[] BranchOptimizadas;
         //delete[] IDs;
           
          
       
         cout << "Solucion Mutada Score " << SMutada->getObjective(0) << " Lik: " << SMutada->getObjective(1) <<  endl;
       
         if(comparator->compare(solution, SMutada)==1){
               cout << "Mejor Solucion MO Mutada "  << endl; //<< SMutada->getObjective(0) << " Lik: " << SMutada->getObjective(1) << endl;

               Pt2->setTree(new TreeTemplate<Node>(*treeMutada));
                   
               solution->setObjective(0,SMutada->getObjective(0));
               solution->setObjective(1,SMutada->getObjective(1));
               
               i=a.size();

         }
        
         //delete a[i];
     }
     
      delete SMutada;
  }
   
  //problem_->evaluate(solution);
  //cout << "Scores Antes Modificacion Ramas : " << solution->getObjective(0) << " Lik: " << solution->getObjective(1) << endl;
  //ModificarRamasDistGamma(solution);
  
  //cout << "Delete ambas " << endl;
  
 // if(OptRamas || OptModeloyTasaDist)  OptimizarRamasyParamModeloSust(solution);
  
  //cout << "Lik optimizado Paramas " << OptimizarParamModeloSust(solution) << endl;;
  //problem_->evaluate(solution);
  cout << "Scores Final: " << solution->getObjective(0) << " Lik: " << solution->getObjective(1) << endl;
  cout <<"============================================================" << endl;
}



//Busca 5 mejor parsimonioso, y al final les aplica Newton a todas ramas y si domina contra solution se hace el reemplazo
void PhylogeneticMutation::PPN_LS6(Solution * solution){
  cout <<"============================================================" << endl;
  cout << "Scores Inicio: " << solution->getObjective(0) << " Lik: " << solution->getObjective(1) << endl;
  
  vector<double> v;
  vector<TreeTemplate<Node>*> a;
  vector<double>::iterator it;
  vector<TreeTemplate<Node>*>::iterator it2;  
  double ParsimonyScore;
  double MenorParsimonia = solution->getObjective(0);
     
  Phylogeny * problem_ = (Phylogeny *) solution->getProblem();
  PhyloTree * Pt2 = ((PhyloTree*) solution->getDecisionVariables()[0]);

  
  //a.push_back(Pt2->getTreeCopy());  v.push_back(solution->getObjective(0)); 

  
  TreeTemplate<Node> * treeMutada = new TreeTemplate<Node>(*Pt2->getTree());
  
  DRTreeParsimonyScore * Par =	new DRTreeParsimonyScore(*Pt2->getTree(), *problem_->getSites() ,false,true);
  TreeTemplate<Node> * treeP = Par->getTreeP_();
  
       
  
  Node * Root;
  Node* Nodo1;
  Node* Nodo2;

  int MaxNivel, dmax,d,up,down,u, Iteracion, idN1;
  bool b;
  
  pair< pair<double *, int *>, Node *> pPar;
  pair<double *, int *> pnPar;

  pair< pair<double *, int *>, Node *> pTreeMutada;
  pair<double *, int *> pnTreeMutada;

  
  Root=treeP->getRootNode();
  MaxNivel=0;
  for(int k=0;k<Root->getNumberOfSons();k++){      MaxNivel+= getNivel(Root->getSon(k));   }

  dmax =MaxNivel; 
  
  vector<int> nodosIDs = treeP->getNodesId();
  int NextNodeID = treeP->getNextId();
  int bsr;
  
  
  for(Iteracion=0; Iteracion<NumIteraciones;Iteracion++){
      
        if (Iteracion%(NumIteraciones/MaxNivel+1)==0) dmax--;
      
        if(dmax < 3) dmax=3;
        else if(dmax > MaxNivel) dmax=MaxNivel;

        do{
              b=true;
              do {
                  do  idN1 =  rand()%nodosIDs.size();
                  while(!treeP->hasNode(nodosIDs[idN1]));
                  
                  Nodo1 =  treeP->getNode( nodosIDs[idN1]);
                  
                  if(Nodo1->hasFather()){
                      if(Nodo1->getFather()->hasFather()) b=false;
                  }
              }while(b);

              //cout << "Nodo1 " << Nodo1->getId()<< endl;

              d=rand()%dmax+1; //Distancia entre 1 y DMax

              u=up=rand()%d+2; //Subir desde 2 a D

             //cout << "dmax " << dmax << " d " << d << " u " << u;

              Nodo2=Nodo1;
              Node* prev;
              while(Nodo2->hasFather() && (u>0)) {
                 prev=Nodo2;
                 Nodo2=Nodo2->getFather();
                 u--;
              }

              down=d+2-up-u;

             //cout << " down " << down << endl;

            /*if (down>0) {
              if (prev->getP()==Rnoeud->getG()) Rnoeud=Rnoeud->getD();
              else Rnoeud=Rnoeud->getG();
              down--;
            }*/

            //cout << "Bajando " << endl;
            while(Nodo2->getNumberOfSons()>1 && (down>0)) {
                  Nodo2 = Nodo2->getSon(rand()% Nodo2->getNumberOfSons());
                  if(Nodo1==Nodo2) {
                      //cout << "N1 es igual N2 getNumberOfSons= " << Nodo2->getNumberOfSons() << endl;
                      Nodo2=Nodo2->getFather();
                  }else  down --;
                  //cout << N2->getId() << " - ";
            }

            //cout << endl << "Nodo2 " << Nodo2->getId()<< endl;

         }while(!SPRvalide (Nodo1,Nodo2));
      
         //cout << "SPR 1" << endl;
         pPar=SPR(Nodo1, Nodo2, bsr); //Sobrr TreeParsimonia
         pnPar = pPar.first;
         //cout << "SPR 2" << endl;

         Par->topologyChangeTested(*new TopologyChangeEvent());
         //cout << "topologyChangeTested 2" << endl;
         
         ParsimonyScore = Par->getScore();
         if( ParsimonyScore < MenorParsimonia){
             
             MenorParsimonia = ParsimonyScore;
             cout << "Mejor Parsimonia SPR " << ParsimonyScore << endl;
             
             pTreeMutada=SPR(treeMutada->getNode(Nodo1->getId()),treeMutada->getNode(Nodo2->getId()), NextNodeID);
             pnTreeMutada = pTreeMutada.first;
             
             int  *IDs = pnTreeMutada.second;
             vector<string> Ramas;
             vector <Node *> nodos = treeMutada->getNodes();
             //Los BarnchNamesPropertys seran los mismos sobre el tree del RHomerLik a Optimizar
             for(int k=0;k<3;k++)  Ramas.push_back(getBrachNameProperty(IDs[k],nodos));
             double * BranchOptimizadas = OptimizarRamasAfterSRP(treeMutada,Pt2, Ramas, problem_, 10000 , 0.00001);
             for(int k=1;k<4;k++) {
                    if(BranchOptimizadas[k]!=0){
                            treeMutada->getNode(IDs[k-1])->setDistanceToFather(BranchOptimizadas[k]);
                    }
             }
                        
             if(!a.empty()){
                it2=a.begin();
                for (it=v.begin()  ; it<v.end(); it++){
                        if(ParsimonyScore<*it){
                                v.insert(it,ParsimonyScore);
                                a.insert(it2,treeMutada->clone());
                                it=v.end();
                        }
                        it2++;
                }
                
                if(v.size()>5) { v.pop_back(); a.pop_back(); }
                
            }else{
                 v.push_back(ParsimonyScore); a.push_back(treeMutada->clone());
            }
             
             delete[] pnTreeMutada.first;       delete[] pnTreeMutada.second;

         }else{
              double *b = pnPar.first;
              if(b[0]==1){
                  //cout << "SPR R 1" << endl;
                  SPR(Nodo1,pPar.second,b);
                  //cout << "SPR R 2" << endl;
              }else{
                  //cout << "SPrrever 1" << endl;
                  SPRreverse(Nodo1,pPar.second,b,bsr);
                  //cout << "SPrrever 2" << endl;
              }
         }
         
        delete[] pnPar.first;       delete[] pnPar.second;
          //if(Iteracion%100==0)      cout << "Iteracion " << Iteracion << endl; //<< " DMax " << dmax << " de " << MaxNivel << endl;
        
  }
  
  delete treeMutada;
  delete Par;
    
  
  if(!a.empty()){
        cout<< "Mejores Arboles Parsimonios " << endl;
        for (int i=0;i<v.size();i++)   cout << v[i] << " ";
        cout << endl;
  
        cout << "Optimizacion Ramas a los bestTreesParsimonios " << endl;
        Solution *SMutada = new Solution(solution); 
        PhyloTree * Pt = (PhyloTree*) SMutada->getDecisionVariables()[0];
        treeMutada = Pt->getTree();
        double NewLik;
  
        for (int i=a.size()-1;i>=0;i--){
       
            
         NewLik = OptimizarRamas(a[i],  Pt, problem_, 2, 0.1);

         treeMutada = a[i];
         Pt->setTree(treeMutada);
          
          //problem_->evaluate(SMutada);
          SMutada->setObjective(0,v[i]);
          SMutada->setObjective(1,NewLik); 
       
         cout << "Solucion Mutada Score " << SMutada->getObjective(0) << " Lik: " << SMutada->getObjective(1) <<  endl;
       
         if(comparator->compare(solution, SMutada)==1){
               cout << "Mejor Solucion MO Mutada "  << endl; //<< SMutada->getObjective(0) << " Lik: " << SMutada->getObjective(1) << endl;

               Pt2->setTree(new TreeTemplate<Node>(*treeMutada));
                   
               solution->setObjective(0,SMutada->getObjective(0));
               solution->setObjective(1,SMutada->getObjective(1));

         }
        //delete a[i];
     }
     
        delete SMutada;
  }
   
  //problem_->evaluate(solution);
  //cout << "Scores Antes Modificacion Ramas : " << solution->getObjective(0) << " Lik: " << solution->getObjective(1) << endl;
  //ModificarRamasDistGamma(solution);
  
  
  
  //cout << "Delete ambas " << endl;
  
 // if(OptRamas || OptModeloyTasaDist)  OptimizarRamasyParamModeloSust(solution);
  //problem_->evaluate(solution);
  cout << "Scores Final: " << solution->getObjective(0) << " Lik: " << solution->getObjective(1) << endl;
  cout <<"============================================================" << endl;
}

/*Intenta mejorar parsimonia aplica Newton 3 ramas e inetta seguir mejorando*/
void PhylogeneticMutation::PPN_LS5(Solution * solution){
  cout <<"============================================================" << endl;
  cout << "Scores Inicio: " << solution->getObjective(0) << " Lik: " << solution->getObjective(1) << endl;
  
  Solution *SMutada = new Solution(solution); 
    
  PhyloTree * Pt = (PhyloTree*) SMutada->getDecisionVariables()[0];
  PhyloTree * Pt2 = ((PhyloTree*) solution->getDecisionVariables()[0]);
  TreeTemplate<Node> * treeMutada = Pt->getTree();
  Phylogeny * problem_ = (Phylogeny *) SMutada->getProblem();

  DRTreeParsimonyScore * Par =	new DRTreeParsimonyScore(*treeMutada, *problem_->getSites() ,false,true);
  TreeTemplate<Node> * treeP = Par->getTreeP_();
  
          
  Node * Root;
  Node* Nodo1;
  Node* Nodo2;

  
  int MaxNivel, dmax,d,up,down,u, Iteracion, idN1;
  bool b;
  
  pair< pair<double *, int *>, Node *> pPar;
  pair<double *, int *> pnPar;

  pair< pair<double *, int *>, Node *> pTreeMutada;
  pair<double *, int *> pnTreeMutada;

  
  Root=treeP->getRootNode();
  MaxNivel=0;
  for(int k=0;k<Root->getNumberOfSons();k++){      MaxNivel+= getNivel(Root->getSon(k));   }

  dmax =MaxNivel; 
  
  vector<int> nodosIDs = treeP->getNodesId();
  int NextNodeID = treeMutada->getNextId();
  int bsr;
  
  
  for(Iteracion=0; Iteracion<NumIteraciones;Iteracion++){
      
        if (Iteracion%(NumIteraciones/MaxNivel+1)==0) dmax--;
      
        if(dmax < 3) dmax=3;
        else if(dmax > MaxNivel) dmax=MaxNivel;

        do{
              b=true;
              do {
                  do  idN1 =  rand()%nodosIDs.size();
                  while(!treeP->hasNode(nodosIDs[idN1]));
                  
                  Nodo1 =  treeP->getNode( nodosIDs[idN1]);
                  
                  if(Nodo1->hasFather()){
                      if(Nodo1->getFather()->hasFather()) b=false;
                  }
              }while(b);

              //cout << "Nodo1 " << Nodo1->getId()<< endl;

              d=rand()%dmax+1; //Distancia entre 1 y DMax

              u=up=rand()%d+2; //Subir desde 2 a D

             //cout << "dmax " << dmax << " d " << d << " u " << u;

              Nodo2=Nodo1;
              Node* prev;
              while(Nodo2->hasFather() && (u>0)) {
                 prev=Nodo2;
                 Nodo2=Nodo2->getFather();
                 u--;
              }

              down=d+2-up-u;

             //cout << " down " << down << endl;

            /*if (down>0) {
              if (prev->getP()==Rnoeud->getG()) Rnoeud=Rnoeud->getD();
              else Rnoeud=Rnoeud->getG();
              down--;
            }*/

            //cout << "Bajando " << endl;
            while(Nodo2->getNumberOfSons()>1 && (down>0)) {
                  Nodo2 = Nodo2->getSon(rand()% Nodo2->getNumberOfSons());
                  if(Nodo1==Nodo2) {
                      //cout << "N1 es igual N2 getNumberOfSons= " << Nodo2->getNumberOfSons() << endl;
                      Nodo2=Nodo2->getFather();
                  }else  down --;
                  //cout << N2->getId() << " - ";
            }

            //cout << endl << "Nodo2 " << Nodo2->getId()<< endl;

         }while(!SPRvalide (Nodo1,Nodo2));
      
         //cout << "SPR 1" << endl;
         pPar=SPR(Nodo1, Nodo2, bsr); //Sobrr TreeParsimonia
         pnPar = pPar.first;
         //cout << "SPR 2" << endl;

          Par->topologyChangeTested(*new TopologyChangeEvent());
         //cout << "topologyChangeTested 2" << endl;
         
         
         if(Par->getScore()  < solution->getObjective(0)){
             
             //cout << "Mejor Parsimonia SPR " << Par->getScore() << endl;
             
             pTreeMutada=SPR(treeMutada->getNode(Nodo1->getId()),treeMutada->getNode(Nodo2->getId()), NextNodeID);
             pnTreeMutada = pTreeMutada.first;
             
             
             int  *IDs = pnTreeMutada.second;
             vector<string> Ramas;
             vector <Node *> nodos = treeMutada->getNodes();
             //Los BarnchNamesPropertys seran los mismos sobre el tree del RHomerLik a Optimizar
             for(int k=0;k<3;k++)  Ramas.push_back(getBrachNameProperty(IDs[k],nodos));

              double * BranchOptimizadas = OptimizarRamasAfterSRP(treeMutada, Pt, Ramas, problem_, 10000 , 0.00001);
              for(int k=1;k<4;k++) {
                  if(BranchOptimizadas[k]!=0){
                      treeMutada->getNode(IDs[k-1])->setDistanceToFather(BranchOptimizadas[k]);
                  }
              }
              
             SMutada->setObjective(0,Par->getScore());
             SMutada->setObjective(1,BranchOptimizadas[0]); //No evaluo la Lik xq la OptNewtonLohizo, solo actual branh optimizadas
             
             delete[] BranchOptimizadas; 
             
             
             //problem_->evaluate(SMutada);
             //cout << "Solucion Mutada Score " << SMutada->getObjective(0) << " Lik: " << SMutada->getObjective(1) <<  endl;
             
             if(comparator->compare(solution, SMutada)==1){
                   cout << "Mejor Solucion MO Mutada "  << SMutada->getObjective(0) << " Lik: " << SMutada->getObjective(1) << endl;

                   Pt2->setTree(new TreeTemplate<Node>(*treeMutada));
                   
                   solution->setObjective(0,SMutada->getObjective(0));
                   solution->setObjective(1,SMutada->getObjective(1));

             }else{
                  double *b = pnPar.first;
                  if(b[0]==1){
                        //cout << "SPR R 1" << endl;
                          SPR(Nodo1,pPar.second,b);
                         //cout << "SPR R 2" << endl;
                  }else{
                         //cout << "SPrrever 1" << endl;
                         SPRreverse(Nodo1,pPar.second,b,bsr);
                         //cout << "SPrrever 2" << endl;
                 }
                 
                 double *b2 = pnTreeMutada.first;
                 if(b2[0]==1){
                        //cout << "SPR R 1" << endl;
                          SPR(treeMutada->getNode(Nodo1->getId()),treeMutada->getNode(pTreeMutada.second->getId()),b2);
                         //cout << "SPR R 2" << endl;
                  }else{
                         //cout << "SPrrever 1" << endl;
                         SPRreverse(treeMutada->getNode(Nodo1->getId()),treeMutada->getNode(pTreeMutada.second->getId()),b2, NextNodeID);
                         //cout << "SPrrever 2" << endl;
                 }
                 
                SMutada->setObjective(0,solution->getObjective(0));
                SMutada->setObjective(1,solution->getObjective(1));
             }
             
             delete[] pnTreeMutada.first;       delete[] pnTreeMutada.second;

         }else{
              double *b = pnPar.first;
              if(b[0]==1){
                  //cout << "SPR R 1" << endl;
                  SPR(Nodo1,pPar.second,b);
                  //cout << "SPR R 2" << endl;
              }else{
                  //cout << "SPrrever 1" << endl;
                  SPRreverse(Nodo1,pPar.second,b,bsr);
                  //cout << "SPrrever 2" << endl;
              }
         }
         
        delete[] pnPar.first;       delete[] pnPar.second;
          //if(Iteracion%100==0)      cout << "Iteracion " << Iteracion << endl; //<< " DMax " << dmax << " de " << MaxNivel << endl;
        
  }
  
  delete Par;
  delete SMutada;
  
  //cout << "Delete ambas " << endl;
  
  //if(OptRamas || OptModeloyTasaDist)  OptimizarRamasyParamModeloSust(solution);
  problem_->evaluate(solution);
  cout << "Scores Final: " << solution->getObjective(0) << " Lik: " << solution->getObjective(1) << endl;
  cout <<"============================================================" << endl;
}

/*Intenta mejorar parsimonia aplica Newton todas ramas e inetta seguir mejorando*/
void PhylogeneticMutation::PPN_LS4(Solution * solution){
  cout <<"============================================================" << endl;
  cout << "Scores Inicio: " << solution->getObjective(0) << " Lik: " << solution->getObjective(1) << endl;
  
  Solution *SMutada = new Solution(solution); 
    
  PhyloTree * Pt = (PhyloTree*) SMutada->getDecisionVariables()[0];
  PhyloTree * Pt2 = ((PhyloTree*) solution->getDecisionVariables()[0]);
  TreeTemplate<Node> * treeMutada = Pt->getTree();
  Phylogeny * problem_ = (Phylogeny *) SMutada->getProblem();

  DRTreeParsimonyScore * Par =	new DRTreeParsimonyScore(*treeMutada, *problem_->getSites() ,false,true);
  TreeTemplate<Node> * treeP = Par->getTreeP_();
  
          
  Node * Root;
  Node* Nodo1;
  Node* Nodo2;

  
  int MaxNivel, dmax,d,up,down,u, Iteracion, idN1;
  bool b;
  
  pair< pair<double *, int *>, Node *> pPar;
  pair<double *, int *> pnPar;

  pair< pair<double *, int *>, Node *> pTreeMutada;
  pair<double *, int *> pnTreeMutada;

  
  Root=treeP->getRootNode();
  MaxNivel=0;
  for(int k=0;k<Root->getNumberOfSons();k++){      MaxNivel+= getNivel(Root->getSon(k));   }

  dmax =MaxNivel; 
  
  vector<int> nodosIDs = treeP->getNodesId();
  int NextNodeID = treeMutada->getNextId();
  int bsr;
  
  
  for(Iteracion=0; Iteracion<NumIteraciones;Iteracion++){
      
        if (Iteracion%(NumIteraciones/MaxNivel+1)==0) dmax--;
      
        if(dmax < 3) dmax=3;
        else if(dmax > MaxNivel) dmax=MaxNivel;

        do{
              b=true;
              do {
                  do  idN1 =  rand()%nodosIDs.size();
                  while(!treeP->hasNode(nodosIDs[idN1]));
                  
                  Nodo1 =  treeP->getNode( nodosIDs[idN1]);
                  
                  if(Nodo1->hasFather()){
                      if(Nodo1->getFather()->hasFather()) b=false;
                  }
              }while(b);

              //cout << "Nodo1 " << Nodo1->getId()<< endl;

              d=rand()%dmax+1; //Distancia entre 1 y DMax

              u=up=rand()%d+2; //Subir desde 2 a D

             //cout << "dmax " << dmax << " d " << d << " u " << u;

              Nodo2=Nodo1;
              Node* prev;
              while(Nodo2->hasFather() && (u>0)) {
                 prev=Nodo2;
                 Nodo2=Nodo2->getFather();
                 u--;
              }

              down=d+2-up-u;

             //cout << " down " << down << endl;

            /*if (down>0) {
              if (prev->getP()==Rnoeud->getG()) Rnoeud=Rnoeud->getD();
              else Rnoeud=Rnoeud->getG();
              down--;
            }*/

            //cout << "Bajando " << endl;
            while(Nodo2->getNumberOfSons()>1 && (down>0)) {
                  Nodo2 = Nodo2->getSon(rand()% Nodo2->getNumberOfSons());
                  if(Nodo1==Nodo2) {
                      //cout << "N1 es igual N2 getNumberOfSons= " << Nodo2->getNumberOfSons() << endl;
                      Nodo2=Nodo2->getFather();
                  }else  down --;
                  //cout << N2->getId() << " - ";
            }

            //cout << endl << "Nodo2 " << Nodo2->getId()<< endl;

         }while(!SPRvalide (Nodo1,Nodo2));
      
         //cout << "SPR 1" << endl;
         pPar=SPR(Nodo1, Nodo2, bsr); //Sobrr TreeParsimonia
         pnPar = pPar.first;
         //cout << "SPR 2" << endl;

          Par->topologyChangeTested(*new TopologyChangeEvent());
         //cout << "topologyChangeTested 2" << endl;
         
         
         if(Par->getScore()  < solution->getObjective(0)){
             
             cout << "Mejor Parsimonia SPR " << Par->getScore() << endl;
             
             TreeTemplate<Node> * TreeMutadaBK = new TreeTemplate<Node>(*treeMutada);
             int NextNodeIDBk=NextNodeID;
             
             pTreeMutada=SPR(treeMutada->getNode(Nodo1->getId()),treeMutada->getNode(Nodo2->getId()), NextNodeID);
             pnTreeMutada = pTreeMutada.first;
             
             
             /*int  *IDs = pnTreeMutada.second;
             vector<string> Ramas;
             vector <Node *> nodos = treeMutada->getNodes();
             //Los BarnchNamesPropertys seran los mismos sobre el tree del RHomerLik a Optimizar
             for(int k=0;k<3;k++)  Ramas.push_back(getBrachNameProperty(IDs[k],nodos));

              double * BranchOptimizadas = OptimizarRamasAfterSRP(treeMutada, Ramas, problem_, 10000 , 0.00001);
              for(int k=1;k<4;k++) {
                  if(BranchOptimizadas[k]!=0){
                      treeMutada->getNode(IDs[k-1])->setDistanceToFather(BranchOptimizadas[k]);
                  }
              }*/
              
              
             double NewLik = OptimizarRamas(treeMutada, Pt, problem_, 10000, 0.00001);
             
             SMutada->setObjective(0,Par->getScore());
             //SMutada->setObjective(1,BranchOptimizadas[0]); //No evaluo la Lik xq la OptNewtonLohizo, solo actual branh optimizadas
             SMutada->setObjective(1,NewLik); //No evaluo la Lik xq la OptNewtonLohizo, solo actual branh optimizadas
             //delete[] BranchOptimizadas; 
             
             
             //problem_->evaluate(SMutada);
             cout << "Solucion Mutada Score " << SMutada->getObjective(0) << " Lik: " << SMutada->getObjective(1) <<  endl;
             
             if(comparator->compare(solution, SMutada)==1){
                   cout << "Mejor Solucion MO Mutada "  << endl; //<< SMutada->getObjective(0) << " Lik: " << SMutada->getObjective(1) << endl;

                   Pt2->setTree(new TreeTemplate<Node>(*treeMutada));
                   
                   solution->setObjective(0,SMutada->getObjective(0));
                   solution->setObjective(1,SMutada->getObjective(1));

             }else{
                    
                 cout << "NO ES Mejor Solucion MO Mutada, se reversa arbol y ramas" << endl;
                 delete treeMutada;
                 //delete Par;
                 
                 treeMutada  = new TreeTemplate<Node>(*TreeMutadaBK);
                 Pt->setTree(treeMutada);
                 NextNodeID = NextNodeIDBk;
                 delete TreeMutadaBK;
                 
                 //Par =	new DRTreeParsimonyScore(*treeMutada, *problem_->getSites() ,false,true);
                 //treeP = Par->getTreeP_();
                 //nodosIDs = treeP->getNodesId();
                    
                  double *b = pnPar.first;
                  if(b[0]==1){
                        //cout << "SPR R 1" << endl;
                          SPR(Nodo1,pPar.second,b);
                         //cout << "SPR R 2" << endl;
                  }else{
                         //cout << "SPrrever 1" << endl;
                         SPRreverse(Nodo1,pPar.second,b,bsr);
                         //cout << "SPrrever 2" << endl;
                 }
                 
                 /*double *b2 = pnTreeMutada.first;
                 if(b2[0]==1){
                        //cout << "SPR R 1" << endl;
                          SPR(treeMutada->getNode(Nodo1->getId()),treeMutada->getNode(pTreeMutada.second->getId()),b2);
                         //cout << "SPR R 2" << endl;
                  }else{
                         //cout << "SPrrever 1" << endl;
                         SPRreverse(treeMutada->getNode(Nodo1->getId()),treeMutada->getNode(pTreeMutada.second->getId()),b2, NextNodeID);
                         //cout << "SPrrever 2" << endl;
                 }*/
                 
                 
                 
                SMutada->setObjective(0,solution->getObjective(0));
                SMutada->setObjective(1,solution->getObjective(1));
             }
             
             delete[] pnTreeMutada.first;       delete[] pnTreeMutada.second;

         }else{
              double *b = pnPar.first;
              if(b[0]==1){
                  //cout << "SPR R 1" << endl;
                  SPR(Nodo1,pPar.second,b);
                  //cout << "SPR R 2" << endl;
              }else{
                  //cout << "SPrrever 1" << endl;
                  SPRreverse(Nodo1,pPar.second,b,bsr);
                  //cout << "SPrrever 2" << endl;
              }
         }
         
        delete[] pnPar.first;       delete[] pnPar.second;
          //if(Iteracion%100==0)      cout << "Iteracion " << Iteracion << endl; //<< " DMax " << dmax << " de " << MaxNivel << endl;
        
  }
  
  delete Par;
  delete SMutada;
  
  //cout << "Delete ambas " << endl;
  
  //if(OptRamas || OptModeloyTasaDist)  OptimizarRamasyParamModeloSust(solution);
  problem_->evaluate(solution);
  cout << "Scores Final: " << solution->getObjective(0) << " Lik: " << solution->getObjective(1) << endl;
  cout <<"============================================================" << endl;
}

string PhylogeneticMutation:: getBrachNameProperty(int idnode,vector<Node*> nodos){
  int pos = 0;
  stringstream ss;
  
  while (pos < nodos.size() && nodos[pos]->getId() != idnode) pos++;
  
  if (pos < nodos.size()) {
      ss<<pos; 
      return "BrLen" + ss.str() ;
  } else 
      return "";
}

void PhylogeneticMutation::ModificarRamasDistGamma(Solution * solution){
    
    /*Also modifies branch lengths in 	order to improve the tree likelihood value.
    * Some branches, chosen at random, have their
    * lengths multiplied by a factor obtained from a Γ-distribution (Lewis, 1998)
    */
    
    TreeTemplate<Node> * tree = ((PhyloTree*) solution->getDecisionVariables()[0])->getTree();
    
    //if( PseudoRandom::randDouble() > 0.34 ){
	 double gamma; double distance;
	 vector<Node *> nodes = tree->getNodes();
	 for(unsigned int i = 0; i < nodes.size(); i++){
             if (PseudoRandom::randDouble() <= 0.5) {
                if (nodes[i]->hasDistanceToFather()){
			 distance = nodes[i]->getDistanceToFather();
        		 gamma =  gsl_ran_gamma (random_gsl, randomgsl_alpha, (1.0/randomgsl_alpha) );
			 if (distance * gamma != 0)	 nodes[i]->setDistanceToFather(distance * gamma);
		 }
             }
	}
   // }
    
}
		
/**Retorna vector de double con las 3 ramas Optimizadas, en el mismo orden en que fuen enviadas con las NamRamas de los NodeIds*/
double * PhylogeneticMutation::OptimizarRamasAfterSRP(TreeTemplate<Node> * tree, PhyloTree * Pt, vector<string> Ramas, Phylogeny * p, int NumEvals , double Tolerancia){

    double * brOptimizadas = new double[4] ;
    
    SubstitutionModel * Model = new HKY85(p->alphabet,Pt->kappa, Pt->piA, Pt->piC, Pt->piG, Pt->piT); 
    DiscreteDistribution * RateDist =  new GammaDiscreteDistribution(p->NumCat,Pt->alpha,Pt->beta);
   
    RHomogeneousTreeLikelihood * tl1= new RHomogeneousTreeLikelihood(*tree, *p->sites2_, Model, RateDist, true,false,true);
    tl1->initialize();

    double lk= tl1->getValue();
    tl1->enableFirstOrderDerivatives(true);
    tl1->enableSecondOrderDerivatives(true);
   
   ParameterList pl = tl1->getBranchLengthsParameters();
   ParameterList ps;
   for(int k=0;k<Ramas.size();k++){
       if (pl.hasParameter(Ramas[k])){
            ps.addParameter(pl.getParameter(Ramas[k]));
            //cout << "Rama " << k  << " dentro de BarnchLengtParams de Lik de Opt " << pl.getParameter(Ramas[k]).getName() << " " << pl.getParameter(Ramas[k]).getValue() << endl;
       }else{ //Esto No debria pasar
           cout << "UNA RAMA NO ESTA EN LAS BRACHNLENGHPARAMETR DEL LIK DEL OPTIMIZER" << endl;
           delete tl1;
           brOptimizadas[0]=0; brOptimizadas[1]=0; brOptimizadas[2]=0;
           return brOptimizadas;
       }
   }
   
       
   Optimizer* optimizer;
   //optimizer =new ConjugateGradientMultiDimensions(tl1);
   optimizer = new PseudoNewtonOptimizer(tl1);
   optimizer->setMaximumNumberOfEvaluations(NumEvals);
   optimizer->getStopCondition()->setTolerance(Tolerancia);
   optimizer->setProfiler(NULL);
   optimizer->setMessageHandler(NULL);
   optimizer->setVerbose(0);
   optimizer->setConstraintPolicy(AutoParameter::CONSTRAINTS_AUTO);

   optimizer->init(ps);
   brOptimizadas[0] = optimizer->optimize();

   //cout <<"Optimizacion de 3 Ramas " << lk << endl;

   pl=optimizer->getParameters();
   brOptimizadas[1] = pl[0].getValue(); brOptimizadas[2] = pl[1].getValue(); brOptimizadas[3] = pl[2].getValue();

   delete optimizer;
   //delete tree;
   //tree = new TreeTemplate<Node>(tl1->getTree());
   delete tl1;
   delete Model;
   delete RateDist;
   

   return brOptimizadas;
}

double PhylogeneticMutation::OptimizarRamas(TreeTemplate<Node> * &tree, PhyloTree* Pt, Phylogeny * p, int NumEvals , double Tolerancia){

    if(!OptRamas) return 0;
    
    clock_t t_ini;
    t_ini = clock();     
    
    SubstitutionModel * Model = new HKY85(p->alphabet,Pt->kappa, Pt->piA, Pt->piC, Pt->piG, Pt->piT); 
    DiscreteDistribution * RateDist =  new GammaDiscreteDistribution(p->NumCat,Pt->alpha,Pt->beta);
    
    RHomogeneousTreeLikelihood * tl1= new RHomogeneousTreeLikelihood(*tree, *p->sites2_, Model, RateDist, true,false,true);
    tl1->initialize();

    double lk1= tl1->getValue();
    cout << "Likelihood I " << lk1 << endl;
    
    tl1->enableFirstOrderDerivatives(true);
    tl1->enableSecondOrderDerivatives(true);
   
   ParameterList pl = tl1->getBranchLengthsParameters();
       
   Optimizer* optimizer;
   //optimizer =new ConjugateGradientMultiDimensions(tl1);
   //optimizer =new BfgsMultiDimensions(tl1);
   optimizer = new PseudoNewtonOptimizer(tl1);
   optimizer->setMaximumNumberOfEvaluations(NumEvals);
   optimizer->getStopCondition()->setTolerance(Tolerancia);
   optimizer->setProfiler(NULL);
   optimizer->setMessageHandler(NULL);
   optimizer->setVerbose(0);
   optimizer->setConstraintPolicy(AutoParameter::CONSTRAINTS_AUTO);

   optimizer->init(pl);
   double lk= optimizer->optimize();
   

   
   TreeTemplate<Node>*  tLik = tl1->getTreeP_();
   vector<Node *> nodos= tree->getNodes();
   vector<Node *> nodos2= tLik->getNodes();
   Node * nodo; 
   Node * nodo2;
  
   if(nodos.size()!=nodos2.size()) { 
       cout << "Número Nodos diferentes Tree " << nodos.size() << " TLik " << nodos2.size() << endl;
       
       delete tree;
       tree = new TreeTemplate<Node>();
       tree ->setRootNode(TreeTemplateTools::cloneSubtree<Node>(*tLik->getRootNode()));
            
       //Newick * newickprinttree = new Newick;
       //newickprinttree->write(*tree,"tree");
       //newickprinttree->write(*tLik,"tlik");
      //delete newickprinttree;
       
   }else{
       
        for(int i=0;i<nodos.size();i++){
           nodo=nodos[i]; nodo2=nodos2[i];
           if(nodo2->hasDistanceToFather())
                nodo->setDistanceToFather(nodo2->getDistanceToFather());
           else
             nodo->deleteDistanceToFather();
        }
   }
   
    
   ComportamientoTime <<  ((double) (clock() - t_ini))/ CLOCKS_PER_SEC << endl; 
   ComportamientoML << lk1 - lk   << endl; 
   
   
   //cout <<"Tiempo " << ((double) (clock() - t_ini))/ CLOCKS_PER_SEC  << " DifereML " << lk1-lk << endl;
   
   delete optimizer;
   delete tl1;
   delete Model;
   delete RateDist;

   return lk;
}

double PhylogeneticMutation::OptimizarParamModeloSust(Solution * solution){

    if(!OptimizacionSubstModel) return 0;
    
   // cout <<"============================================================" << endl;
    Phylogeny * Prob = (Phylogeny *) solution->getProblem();
    PhyloTree * Pt  = (PhyloTree*) solution->getDecisionVariables()[0];
    TreeTemplate<Node> * t;  
    t = Pt->getTree();
    
    
   SubstitutionModel * Model = new HKY85(Prob->alphabet,Pt->kappa, Pt->piA, Pt->piC, Pt->piG, Pt->piT); 
   DiscreteDistribution * RateDist =  new GammaDiscreteDistribution(Prob->NumCat,Pt->alpha,Pt->beta);
      
    DiscreteRatesAcrossSitesTreeLikelihood * tl1= new RHomogeneousTreeLikelihood(*t, *Prob->sites2_,Model, RateDist, true,false,true);
    tl1->initialize();

    double lk= tl1->getValue();

    DerivableSecondOrder* f = tl1;
    MetaOptimizerInfos* desc = new MetaOptimizerInfos();
    MetaOptimizer* poptimizer = 0;
         //  if (MetodoOptimizacionSubstModel == OptimizationTools::OPTIMIZATION_BRENT){
               
               ParameterList plsm = tl1->getSubstitutionModelParameters();
               desc->addOptimizer("Substitution model parameter", new SimpleMultiDimensions(f), plsm.getParameterNames(), 0, MetaOptimizerInfos::IT_TYPE_STEP);
     
                //for(int m=0;m<plsm.size();m++){ cout << "Par " << m << " " << plsm[m].getName() << " " << plsm[m].getValue() << endl;}
               
               ParameterList plrd = tl1->getRateDistributionParameters();
               desc->addOptimizer("Rate distribution parameter", new SimpleMultiDimensions(f), plrd.getParameterNames(), 0, MetaOptimizerInfos::IT_TYPE_STEP);
     
                //for(int m=0;m<plrd.size();m++){cout << "Par " << m << " " << plrd[m].getName() << " " << plrd[m].getValue() << endl;}
               
               poptimizer = new MetaOptimizer(f, desc, 0);
               
          /* }   else if (MetodoOptOtrosParam == OptimizationTools::OPTIMIZATION_BFGS){
     
               vector<string> vNameDer;
               AbstractNumericalDerivative* fnum = new ThreePointsNumericalDerivative(f);
               
               ParameterList plsm = tl->getSubstitutionModelParameters();
               vNameDer = plsm.getParameterNames();
          
               ParameterList plrd = tl->getRateDistributionParameters();
               vector<string> vNameDer2 = plrd.getParameterNames();

               vNameDer.insert(vNameDer.begin(), vNameDer2.begin(), vNameDer2.end());
               fnum->setParametersToDerivate(vNameDer);
 
              desc->addOptimizer("Rate & model distribution parameters", new BfgsMultiDimensions(fnum), vNameDer, 1, MetaOptimizerInfos::IT_TYPE_FULL);
              poptimizer = new MetaOptimizer(fnum, desc, 0);
        }
    
        }else {
             
        }*/

        poptimizer->setVerbose(0);
        poptimizer->setMaximumNumberOfEvaluations(NumIterOptSubstModel);
        poptimizer->getStopCondition()->setTolerance(TolerenciaOptSubstModel);
        
        poptimizer->setProfiler(NULL);
        poptimizer->setMessageHandler(NULL);
  
        poptimizer->setConstraintPolicy(AutoParameter::CONSTRAINTS_AUTO);
        
        ParameterList pl2 = plsm;
        pl2.addParameters(plrd);
        
        poptimizer->init(pl2); //tl1->getParameters()
        
        double lk2=poptimizer->optimize();
        cout << "Optimización SubstModel Lik " << lk << " OptimiLik " <<  lk2 << " Mejoramiento " << lk-lk2<< endl;
        
        ParameterList pl = poptimizer->getParameters();
        //for(int m=0;m<pl.size();m++){ cout << "Par " << m << " " << pl[m].getName() << " " << pl[m].getValue() << endl;      }
        //cout << "NumberOfEvaluations " << poptimizer->getNumberOfEvaluations() << endl;
   
         Pt->kappa = pl.getParameterValue("HKY85.kappa");
         double theta_  = pl.getParameterValue("HKY85.theta");
         double theta1_ = pl.getParameterValue("HKY85.theta1");
         double theta2_ = pl.getParameterValue("HKY85.theta2");
                
         Pt->piA = theta1_ * (1. - theta_);
         Pt->piC = (1. - theta2_) * theta_;
         Pt->piG = theta2_ * theta_;
         Pt->piT =(1. - theta1_) * (1. - theta_);
       
         Pt->alpha = pl.getParameterValue("Gamma.alpha");
         Pt->beta = pl.getParameterValue("Gamma.beta");
         
        
         
         delete tl1;
         delete Model;
         delete RateDist;
         delete poptimizer;
        
         //cout <<"============================================================" << endl;
         return lk2;
       
}

/************** DEMORA UN MUNDO (186 Y 218) PARA HACER EN CADA ITERACION *****************/
double PhylogeneticMutation::OptimizarRamasyParamModeloSust(Solution * solution){

    if(!OptimizacionSubstModel and !OptRamas) return 0;
    
    clock_t t_ini;
    t_ini = clock(); 
    
    Phylogeny * Prob = (Phylogeny *) solution->getProblem();
    PhyloTree * Pt  = (PhyloTree*) solution->getDecisionVariables()[0];
    TreeTemplate<Node> * t;  
    t = Pt->getTree();
    
    
   SubstitutionModel * Model = new HKY85(Prob->alphabet,Pt->kappa, Pt->piA, Pt->piC, Pt->piG, Pt->piT); 
   DiscreteDistribution * RateDist =  new GammaDiscreteDistribution(Prob->NumCat,Pt->alpha,Pt->beta);
      
    RHomogeneousTreeLikelihood * tl= new RHomogeneousTreeLikelihood(*t, *Prob->sites2_,Model, RateDist, true,false,true);
    tl->initialize();

    double lk= tl->getValue();
    
    
     DerivableSecondOrder* f = tl;
     ParameterList pl; // = tl->getParameters();
     MetaOptimizerInfos* desc = new MetaOptimizerInfos();
     MetaOptimizer* poptimizer = 0;
     //AbstractNumericalDerivative* fnum = new ThreePointsNumericalDerivative(f);

      if(OptRamas){

      if (MetodoOptRamas == OptimizationTools::OPTIMIZATION_GRADIENT)
           desc->addOptimizer("Branch length parameters", new ConjugateGradientMultiDimensions(f), tl->getBranchLengthsParameters().getParameterNames(), 2, MetaOptimizerInfos::IT_TYPE_FULL);
      else if (MetodoOptRamas == OptimizationTools::OPTIMIZATION_NEWTON)
           desc->addOptimizer("Branch length parameters", new PseudoNewtonOptimizer(f), tl->getBranchLengthsParameters().getParameterNames(), 2, MetaOptimizerInfos::IT_TYPE_FULL);
      else if (MetodoOptRamas == OptimizationTools::OPTIMIZATION_BFGS)
           desc->addOptimizer("Branch length parameters", new BfgsMultiDimensions(f), tl->getBranchLengthsParameters().getParameterNames(), 2, MetaOptimizerInfos::IT_TYPE_FULL);

      pl.addParameters(tl->getBranchLengthsParameters());
    }
     
     if(OptimizacionSubstModel){
    // if (optMethodModel == OPTIMIZATION_BRENT)
    //{
       ParameterList plsm = tl->getSubstitutionModelParameters();
       desc->addOptimizer("Substitution model parameter", new SimpleMultiDimensions(f), plsm.getParameterNames(), 0, MetaOptimizerInfos::IT_TYPE_STEP);
       //for(int m=0;m<plsm.size();m++){ cout << "Par " << m << " " << plsm[m].getName() << " " << plsm[m].getValue() << endl;   }

      ParameterList plrd =tl->getRateDistributionParameters();
      desc->addOptimizer("Rate distribution parameter", new SimpleMultiDimensions(f), plrd.getParameterNames(), 0, MetaOptimizerInfos::IT_TYPE_STEP);
      //for(int m=0;m<plrd.size();m++){ cout << "Par " << m << " " << plrd[m].getName() << " " << plrd[m].getValue() << endl;}
      
     //}
     /*else if (optMethodModel == OPTIMIZATION_BFGS)
     {
       vector<string> vNameDer;
   
       ParameterList plsm = parameters.getCommonParametersWith(tl->getSubstitutionModelParameters());
       vNameDer = plsm.getParameterNames();
   
       ParameterList plrd = parameters.getCommonParametersWith(tl->getRateDistributionParameters());
   
       vector<string> vNameDer2 = plrd.getParameterNames();
   
       vNameDer.insert(vNameDer.begin(), vNameDer2.begin(), vNameDer2.end());
       fnum->setParametersToDerivate(vNameDer);
   
       desc->addOptimizer("Rate & model distribution parameters", new BfgsMultiDimensions(fnum), vNameDer, 1, MetaOptimizerInfos::IT_TYPE_FULL);
       poptimizer = new MetaOptimizer(fnum, desc, nstep);
     }*/
      
      pl.addParameters(plsm); pl.addParameters(plrd);
    }
     
    poptimizer = new MetaOptimizer(f, desc, 0);
     
    poptimizer->setVerbose(0); poptimizer->setProfiler(NULL); poptimizer->setMessageHandler(NULL);
    poptimizer->setMaximumNumberOfEvaluations(NumIterOptRamas);
    poptimizer->getStopCondition()->setTolerance(TolerenciaOptRamas);
   
  
    poptimizer->setConstraintPolicy(AutoParameter::CONSTRAINTS_AUTO);
    poptimizer->init(pl);
    double lk2=poptimizer->optimize();
    //cout << " Likelihood I " << lk << " Optimi Lik " <<  lk2 << " Diferencia " << lk-lk2<< endl;
    cout << " Likelihood I " << lk << endl;
   
    pl = poptimizer->getParameters();
    //for(int m=0;m<pl.size();m++){  cout << "Par " << m << " " << pl[m].getName() << " " << pl[m].getValue() << endl;     }
   
    
    double theta_  = pl.hasParameter("HKY85.theta")?pl.getParameterValue("HKY85.theta"):0;
    double theta1_ = pl.hasParameter("HKY85.theta1")?pl.getParameterValue("HKY85.theta1"):0;
    double theta2_ = pl.hasParameter("HKY85.theta2")?pl.getParameterValue("HKY85.theta2"):0;

    if(theta_!=0 and theta1_!=0 and theta2_!=0){
        Pt->piA = theta1_ * (1. - theta_);
        Pt->piC = (1. - theta2_) * theta_;
        Pt->piG = theta2_ * theta_;
        Pt->piT =(1. - theta1_) * (1. - theta_);
    }

    if(pl.hasParameter("HKY85.kappa"))  Pt->kappa = pl.getParameterValue("HKY85.kappa");
    if(pl.hasParameter("Gamma.alpha"))  Pt->alpha = pl.getParameterValue("Gamma.alpha");
    if(pl.hasParameter("Gamma.beta"))  Pt->beta = pl.getParameterValue("Gamma.beta");
         
         
     TreeTemplate<Node>*  tLik = tl->getTreeP_();
     vector<Node *> nodos= t->getNodes();
     vector<Node *> nodos2= tLik->getNodes();
     Node * nodo; 
     Node * nodo2;
     
     if(nodos.size()!=nodos2.size()) { 
       cout << "Número Nodos diferentes Tree " << nodos.size() << " TLik " << nodos2.size() << endl;
       
       delete t;
       t = new TreeTemplate<Node>();
       t ->setRootNode(TreeTemplateTools::cloneSubtree<Node>(*tLik->getRootNode()));
            
       //Newick * newickprinttree = new Newick;
       //newickprinttree->write(*tree,"tree");
       //newickprinttree->write(*tLik,"tlik");
      //delete newickprinttree;
       
   }else{

         for(int i=0;i<nodos.size();i++){
            nodo=nodos[i]; nodo2=nodos2[i];
            if(nodo2->hasDistanceToFather())
                nodo->setDistanceToFather(nodo2->getDistanceToFather());
            else
                nodo->deleteDistanceToFather();
         }
   }
         
    //p1->setModel(); p1->setRateDistribution();
    //Prob->evaluate(solution);
    //cout << "Evaluado 2 " << solution->getObjective(1) << " y Evaluador por el Optimi " << lk2 << endl;
         
     delete tl;
     delete Model;
     delete RateDist;
     delete poptimizer;

     ComportamientoTime <<  ((double) (clock() - t_ini))/ CLOCKS_PER_SEC << endl; 
     ComportamientoML << lk - lk2   << endl; 
   
     return lk2;
     
     
       
}

/*double PhylogeneticMutation::OptimizarRamasyParamModeloSust(Solution * solution){

         DiscreteRatesAcrossSitesTreeLikelihood *tl;
         Phylogeny *p = (Phylogeny *) solution->getProblem();
         PhyloTree* Pt  = (PhyloTree*) solution->getDecisionVariables()[0];
         TreeTemplate<Node> * tree = Pt->getTree();
  
         tl= new RHomogeneousTreeLikelihood(*tree, *p->sites2_, p->model, p->rateDist, true,false,true);
         tl->initialize();
         
         double lk= tl->getValue();
         
         DerivableSecondOrder* f = tl;

         MetaOptimizerInfos* desc = new MetaOptimizerInfos();
         MetaOptimizer* poptimizer = 0;
        
   
         if(OptRamas){
             
           if (MetodoOptRamas == OptimizationTools::OPTIMIZATION_GRADIENT)
                desc->addOptimizer("Branch length parameters", new ConjugateGradientMultiDimensions(f), tl->getBranchLengthsParameters().getParameterNames(), 2, MetaOptimizerInfos::IT_TYPE_FULL);
           else if (MetodoOptRamas == OptimizationTools::OPTIMIZATION_NEWTON)
                desc->addOptimizer("Branch length parameters", new PseudoNewtonOptimizer(f), tl->getBranchLengthsParameters().getParameterNames(), 2, MetaOptimizerInfos::IT_TYPE_FULL);
           else if (MetodoOptRamas == OptimizationTools::OPTIMIZATION_BFGS)
                desc->addOptimizer("Branch length parameters", new BfgsMultiDimensions(f), tl->getBranchLengthsParameters().getParameterNames(), 2, MetaOptimizerInfos::IT_TYPE_FULL);
         
         }

      
                 
        if(OptimizacionSubstModel){
            
           if (MetodoOptOtrosParam == OptimizationTools::OPTIMIZATION_BRENT){
                
               ParameterList plsm = tl->getSubstitutionModelParameters();
               desc->addOptimizer("Substitution model parameter", new SimpleMultiDimensions(f), plsm.getParameterNames(), 0, MetaOptimizerInfos::IT_TYPE_STEP);
     
               ParameterList plrd = tl->getRateDistributionParameters();
               desc->addOptimizer("Rate distribution parameter", new SimpleMultiDimensions(f), plrd.getParameterNames(), 0, MetaOptimizerInfos::IT_TYPE_STEP);
     
               poptimizer = new MetaOptimizer(f, desc, 0);
               
           }   else if (MetodoOptOtrosParam == OptimizationTools::OPTIMIZATION_BFGS){
     
               vector<string> vNameDer;
               AbstractNumericalDerivative* fnum = new ThreePointsNumericalDerivative(f);
               
               ParameterList plsm = tl->getSubstitutionModelParameters();
               vNameDer = plsm.getParameterNames();
          
               ParameterList plrd = tl->getRateDistributionParameters();
               vector<string> vNameDer2 = plrd.getParameterNames();

               vNameDer.insert(vNameDer.begin(), vNameDer2.begin(), vNameDer2.end());
               fnum->setParametersToDerivate(vNameDer);
 
              desc->addOptimizer("Rate & model distribution parameters", new BfgsMultiDimensions(fnum), vNameDer, 1, MetaOptimizerInfos::IT_TYPE_FULL);
              poptimizer = new MetaOptimizer(fnum, desc, 0);
        }
    
        }else {
               poptimizer = new MetaOptimizer(f, desc, 0);
        }
   
        poptimizer->setVerbose(0);
        poptimizer->setMaximumNumberOfEvaluations(NumIterOptRamas);
        poptimizer->getStopCondition()->setTolerance(TolerenciaOptRamas);
        
        poptimizer->setProfiler(NULL);
        poptimizer->setMessageHandler(NULL);
  
        poptimizer->setConstraintPolicy(AutoParameter::CONSTRAINTS_AUTO);
        //NaNListener* nanListener = new NaNListener(poptimizer, tl);
        //poptimizer->addOptimizationListener(nanListener);
        poptimizer->init(tl->getParameters());
        double lk2= poptimizer->optimize();
        
        
        cout << "LK " << lk << " Optimizado " <<  lk2 << " Mejora " << lk2-lk << endl;;
  
        //cout << "NumberOfEvaluations " << poptimizer->getNumberOfEvaluations() << endl;
   
        delete tree;
        Pt->setTree(new TreeTemplate<Node>(tl->getTree()));
         
        delete tl;
        delete poptimizer;
        
        return lk2;
}*/

/**
 * Executes the operation
 * @param object An object containing a solution
 * @return An object containing the mutated solution
 * @throws JMException
 */

pair< pair<double *, int *>, Node *> PhylogeneticMutation::SPR(Node * Nodo1, Node * Nodo2, int &NextIDNode){
    
    pair<pair<double *, int *>,Node*> p;
    int PosNodo;
    double distancetofather=0;
    double * b = new double[5]; //0 tipo, 1 brLenHermano, 2 brLenNodo2, 3 brLenNod1, 4 brLenPadre
    int * IDs = new int[3];  //0 IDNodoPadre, 1 IDNodo1, 2 IDNodo2
    Node * Padre;
    Node * Padre2;
    Node * GP;
    Node * Hermano;
  
    Padre=Nodo1->getFather();
    if (Nodo1->hasDistanceToFather()) b[3] = Nodo1->getDistanceToFather(); else b[3] =0 ;

    if(Padre->getNumberOfSons()==2){ //Si tiene 2 hijos Collapse Brother por Father
       PosNodo= Padre->getSonPosition(Nodo1);
       Hermano = Padre->getSon(PosNodo==0?1:0);

       //cout << "Hermano " << endl;
       if (Hermano->hasDistanceToFather()) {
           distancetofather = Hermano->getDistanceToFather();
           b[1] = distancetofather;
       }else      
           b[1] = 0;
       

       //Quito al Padre sin el hermano, y ubico al hermano en vez del Padre
       Padre->removeSon(Hermano);
       GP = Padre->getFather();
       GP->setSon(GP->getSonPosition(Padre),Hermano);
       
       //cout << "Set Son Hermano" << endl;

       if(Padre->hasDistanceToFather()) {
               distancetofather+=Padre->getDistanceToFather();
               b[4] = Padre->getDistanceToFather();
       }else b[4] =0;
           
       Hermano->setDistanceToFather(distancetofather);
       
       //cout << " Hermano 3" << endl;       
       
       b[0] = 1; //Normal Nodos con dos Hijos
       p.second=Hermano;
      

     }else{ //Si tiene mas de un hermano, no se hace Collapse

       PosNodo= Padre->getSonPosition(Nodo1);
       Hermano = Padre->getSon(PosNodo==0?1:0);

       //cout << "Hermano 2" << endl;
       
       Padre->removeSon(Nodo1); //NO Elimina el NODO solo lo eliminar dle Vector de Sons

       Padre = new Node(NextIDNode++);
       Padre->addSon(Nodo1);
       
       b[0] = 2; //Nodo con mas de 2 Hijos SPRReverse
       p.second=Hermano;
     }

     distancetofather=0;
     
     Padre2 = Nodo2->getFather();
     
     //cout << "Hermano 1" << endl;
     
     if(Nodo2->hasDistanceToFather()) {
         distancetofather = Nodo2->getDistanceToFather();
         b[2]=distancetofather;
     }else   b[2]=0;
     
     
     
     //cout << "PAdre " << endl;

     Padre2->setSon(Padre2->getSonPosition(Nodo2),Padre);
     
     Padre->setDistanceToFather(distancetofather/2);
     
     //cout << "PAdre2 " << endl;

     //Agrego al Nodo2 como hijo del Padre
     Padre->addSon(Nodo2);
     
     Nodo2->setDistanceToFather(distancetofather/2);
     //cout << "PAdre 3 " << endl;
     
     //cout << "Herman ID " << Hermano->getId() << endl;
     IDs[0] = Padre->getId();      IDs[1] = Nodo1->getId();     IDs[2] = Nodo2->getId();
     
     /*if(Padre->hasDistanceToFather() and Nodo1->hasDistanceToFather() and Nodo2->hasDistanceToFather())
        if(Padre->getDistanceToFather()>0 and Nodo1->getDistanceToFather()>0 and Nodo2->getDistanceToFather()>0)
        cout << "Ramas a Optimizar dentro SPR " << Padre->getDistanceToFather() << " - " << Nodo1->getDistanceToFather() << " - " << Nodo2->getDistanceToFather() << endl;
     */
     pair<double *, int *> pn;
     pn.first=b; pn.second=IDs;
     
     p.first = pn;
     return p;
}

//SPR de Reserva a estado Anterior
void PhylogeneticMutation::SPR(Node * Nodo1, Node * Nodo2, double *b){
    
   //b -- 0 tipo, 1 brLenHermano, 2 brLenNodo2, 3 brLenNod1, 4 brLenPadre
    int PosNodo;
    Node * Padre;
    Node * Padre2;
    Node * GP;
    Node * Hermano;
  
    Padre=Nodo1->getFather();
    if (b[3]!= 0) Nodo1->setDistanceToFather(b[3]);

    PosNodo= Padre->getSonPosition(Nodo1);
   Hermano = Padre->getSon(PosNodo==0?1:0);
   if (b[2]!= 0) Hermano->setDistanceToFather(b[2]);

   //cout << "Hermano " << endl;

   //Quito al Padre sin el hermano, y ubico al hermano en vez del Padre
   Padre->removeSon(Hermano);
   GP = Padre->getFather();
   GP->setSon(GP->getSonPosition(Padre),Hermano);

   //cout << "Set Son Hermano" << endl;

  Padre2 = Nodo2->getFather();
     
  //cout << "PAdre " << endl;

   Padre2->setSon(Padre2->getSonPosition(Nodo2),Padre);
   if(b[4] != 0) Padre->setDistanceToFather(b[4]);

   //cout << "PAdre2 " << endl;

   //Agrego al Nodo2 como hijo del Padre
   Padre->addSon(Nodo2);
   if(b[1] != 0) Nodo2->setDistanceToFather(b[1]);
     //cout << "PAdre 3 " << endl;
     
     //cout << "Herman ID " << Hermano->getId() << endl;
      
}

void PhylogeneticMutation::SPRreverse(Node * Nodo1, Node * Nodo2 , double *b,int &NextIDNode){
    
    int PosNodo;
    Node * Padre;
    Node * Padre2;
    Node * GP;
    Node * Hermano;
  
    Padre=Nodo1->getFather();
    

    PosNodo= Padre->getSonPosition(Nodo1);
    Hermano = Padre->getSon(PosNodo==0?1:0);
    if (b[2]!= 0) Hermano->setDistanceToFather(b[2]);
   
     //Quito al Padre sin el hermano, y ubico al hermano en vez del Padre
     Padre->removeSon(Hermano);
     GP = Padre->getFather();
     GP->setSon(GP->getSonPosition(Padre),Hermano);


     delete Padre; NextIDNode--;
     Padre2 = Nodo2->getFather();
     //Agrego al Nodo2 como hijo del Padre
     Padre2->addSon(Nodo1);
     if (b[3]!= 0) Nodo1->setDistanceToFather(b[3]);
     //Nodo1->setDistanceToFather(distancetofather/2);
}


/*void PhylogeneticMutation::ChangeBranchLenghth(Node * Nodo, double length, NNIHomogeneousTreeLikelihood * &NNILik  ){
    int pos=0;
    stringstream ss;
    
    vector<Node*> Nodos = NNILik->getnodes_();
    while (pos < Nodos.size() && Nodos[pos]->getId() != Nodo->getId()) pos++;
    if (pos < Nodos.size()) {
          ss << pos;
          string name = "BrLen" + ss.str();
          //cout << "name " << name << " value " << length << endl;
          
          NNILik->getbrLenParameters_().setParameterValue(name, length);
          //getParameter_(name).setValue(length);
          NNILik->getbrLenNNIParams().addParameter(NNILik->getBranchLengthsParameters().getParameter(name));
          
          //cout << "Valor " << NNILik->getbrLenParameters_().getParameter(name).getValue() << endl;      
    
    }
    
}*/
    
    
int PhylogeneticMutation::getNivel(Node* nodo){
    int Max=-1;
      
    if(nodo->isLeaf()){
        return 0;
    }else{
        
        vector<int> V;
        for(int i=0;i<nodo->getNumberOfSons();i++){
            V.push_back(getNivel(nodo->getSon(i)));
        }
        for(int i=0;i<nodo->getNumberOfSons();i++){
            if(V[i]>Max) Max=V[i];
        }
        return Max+1;
    }
}

int  PhylogeneticMutation::SPRvalide (Node* N1, Node* N2) {
    if (!N2->hasFather()) return 0;
    if (N1->getFather()==N2->getFather()) return 0;
    if (N1->getFather()==N2) return 0;
    
    return 1;
}


void * PhylogeneticMutation::execute(void *object) {
  Solution *solution = (Solution *)object;
  // TODO: VALID_TYPES?
  //double probability = *(double *)getParameter("probability");
  doMutation(mutationProbability_, solution);
  return solution;
} // execute
 

